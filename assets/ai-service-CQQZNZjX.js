import{f as L,N as Z,j as _,z as w,L as v,a9 as H,x as Q,y as tt,aa as et,Q as b}from"./main-CKpV1Fmo.js";const st="events/aiservice/streamStarted",rt="events/aiservice/streamChunk",nt="events/aiservice/streamComplete",I="events/aiservice/streamError",ot="events/aiservice/aiConfigChanged",at="events/aiservice/agentWorkflowStarted",it="events/aiservice/agentWorkflowComplete",ct="events/aiservice/agentWorkflowError",lt="aiservice.agents",ut="aiservice.chatProviders",dt="aiservice.promptEnhancers",A="aiConfig",ht="appsupport",ft={defaultProvider:"openai",providers:[],requireToolApproval:!0},gt=10;class j{constructor(){this.decoder=new TextDecoder,this.usage=null}async*readLines(t){let e="";this.usage=null;try{for(;;){const{done:s,value:n}=await t.read();if(s)break;e+=this.decoder.decode(n,{stream:!0});const r=e.split(`
`);e=r.pop()||"";for(const o of r)o.trim()&&(yield*this.processLine(o))}e.trim()&&(yield*this.processLine(e)),yield this.makeDoneChunk()}finally{t.releaseLock()}}makeDoneChunk(){const t={type:"done",content:""};return this.usage&&(t.metadata={usage:this.usage}),t}}class pt extends j{async*parse(t){yield*this.readLines(t)}async*processLine(t){if(!t.startsWith("data: "))return;const e=t.slice(6).trim();if(e==="[DONE]"){yield this.makeDoneChunk();return}try{const s=JSON.parse(e);if(s.error){yield{type:"error",content:s.error.message||"Unknown error",metadata:s.error};return}this.extractUsage(s);const n=this.parseChunk(s);n&&(yield n)}catch{}}extractUsage(t){if(!t.usage)return;const e=t.usage;this.usage={promptTokens:e.prompt_tokens||0,completionTokens:e.completion_tokens||0,totalTokens:e.total_tokens||0,estimated:!1}}parseChunk(t){const e=t.choices?.[0]?.delta,s=t.choices?.[0];if(e?.content)return{type:"token",content:e.content,message:{role:e.role||"assistant",content:s?.message?.content||e.content}};if(s?.message?.tool_calls){const n=this.parseToolCalls(s.message.tool_calls,!0);if(n.length>0)return{type:"token",content:"",toolCalls:n}}else if(e?.tool_calls||s?.delta?.tool_calls){const n=this.parseToolCalls(e?.tool_calls||s?.delta?.tool_calls||[],!1);if(n.length>0)return{type:"token",content:"",toolCalls:n}}return null}parseToolCalls(t,e){return t.filter(s=>s.function!==void 0).map((s,n)=>({id:s.id||`call_${s.index!==void 0?s.index:n}_${Date.now()}`,type:"function",function:{name:s.function?.name||"",arguments:s.function?.arguments||(e?"{}":"")},_index:s.index!==void 0?s.index:n}))}}class mt extends j{async*parse(t){yield*this.readLines(t)}async*processLine(t){try{const e=JSON.parse(t);if(e.error){yield{type:"error",content:e.error,metadata:e};return}if(e.done){this.extractUsage(e),yield this.makeDoneChunk();return}const s=this.parseToken(e);s&&(yield s)}catch{}}extractUsage(t){if(t.prompt_eval_count===void 0&&t.eval_count===void 0)return;const e=t.prompt_eval_count||0,s=t.eval_count||0;this.usage={promptTokens:e,completionTokens:s,totalTokens:e+s,estimated:!1}}parseToken(t){return t.message?.content?{type:"token",content:t.message.content,message:{role:t.message.role||"assistant",content:t.message.content}}:t.response?{type:"token",content:t.response,message:{role:"assistant",content:t.response}}:null}}async function q(i,t,e){let s="";const n=e.getProvider(t);for await(const r of n.stream({model:t.model,messages:i,chatConfig:t}))r.type==="token"&&(s+=r.content);return s}function yt(i){if(!i)return null;if(i.includes("/v1/chat/completions"))return i.replace("/v1/chat/completions","");if(i.includes("/api/v1/chat/completions"))return i.replace("/api/v1/chat/completions","");if(i.includes("/api/chat/completion"))return i.replace("/api/chat/completion","");try{const t=new URL(i);return`${t.protocol}//${t.host}`}catch{return null}}class J{createParser(t,e){return t.includes("text/event-stream")||e.includes("openai")?new pt:new mt}async getAvailableModels(t){if(!t.chatApiEndpoint)return[];const e=yt(t.chatApiEndpoint);if(!e)return[];try{const s={"Content-Type":"application/json"};t.apiKey&&(s.Authorization=`Bearer ${t.apiKey}`);const n=await fetch(`${e}/v1/models`,{method:"GET",headers:s});return n.ok?((await n.json()).data||[]).map(o=>({id:o.id,name:o.name||o.id})):[]}catch{return[]}}async*stream(t){const e={model:t.model,stream:!0,messages:t.messages,...t.chatConfig.parameters};t.tools&&t.tools.length>0&&(e.tools=t.tools,e.tool_choice="auto");const s=await fetch(t.chatConfig.chatApiEndpoint,{method:"POST",headers:{Authorization:`Bearer ${t.chatConfig.apiKey}`,"Content-Type":"application/json",Accept:"text/event-stream"},body:JSON.stringify(e),signal:t.signal});if(!s.ok){const a=await s.text().catch(()=>"Unknown error");yield{type:"error",content:`HTTP ${s.status}: ${a}`,metadata:{status:s.status}};return}if(!s.body){yield{type:"error",content:"Response body is null or empty",metadata:{status:s.status}};return}const n=s.body.getReader();if(!n){yield{type:"error",content:"Response body is not readable"};return}const r=s.headers.get("content-type")||"",o=this.createParser(r,t.chatConfig.chatApiEndpoint);try{for await(const a of o.parse(n))yield a}catch(a){yield{type:"error",content:a instanceof Error?a.message:"Failed to parse response stream",metadata:{error:a,contentType:r}}}}}class Ct extends J{constructor(){super(...arguments),this.name="openai"}canHandle(t){return t.chatApiEndpoint.includes("openai")||t.chatApiEndpoint.includes("v1/chat/completions")}}class wt extends J{constructor(){super(...arguments),this.name="ollama"}canHandle(t){return t.name.toLowerCase()==="ollama"||t.chatApiEndpoint.includes("ollama")||t.chatApiEndpoint.includes("localhost:11434")}}class W{constructor(){this.providers=[],this.providers.push(new Ct),this.providers.push(new wt)}registerProvider(t){this.providers.push(t)}getProvider(t){return this.providers.find(e=>e.canHandle(t))??this.providers[0]}getAllProviders(){return[...this.providers]}}class vt{getAgentContributions(){return L.getContributions(lt)}filterAndSortAgents(t,e){return t.filter(s=>!s.canHandle||s.canHandle(e)).sort((s,n)=>(n.priority||0)-(s.priority||0))}getMatchingAgents(t,e){const s=this.getAgentContributions();if(s.length===0)throw new Error("No agents are registered. The App Support agent should be available from the AI system extension.");const n=e?.length?s.filter(o=>e.includes(o.role)):s,r=this.filterAndSortAgents(n,t);if(e?.length&&r.length===0)throw new Error(`No agents found for requested roles: ${e.join(", ")}. Available: ${s.map(o=>o.role).join(", ")}`);if(!e?.length&&r.length===0)throw new Error(`No agents can handle the current context. Available: ${s.map(o=>o.role).join(", ")}`);return r}}function kt(i){const t={role:i.role,content:i.content};return"tool_call_id"in i&&i.tool_call_id&&(t.tool_call_id=i.tool_call_id),"tool_calls"in i&&i.tool_calls&&(t.tool_calls=i.tool_calls),t}function B(i){return i.map(kt)}const Tt=Z("ToolDetector"),At=["hello","hi","hey","thanks","thank you","bye","goodbye"],xt=["create","open","delete","read","write","edit","save","rename","move","copy","list","show","display","run","execute","build","add","remove","update","modify","change","set","get","find","search","filter","sort","install","uninstall","load","import","export","generate","make","do","perform","call","invoke"],_t=["file","folder","directory","workspace","editor","map","layer","command","tool","extension","script","code","project"];class Et{needsTools(t){if(!t?.trim())return!1;const e=t.toLowerCase().trim();if(At.some(o=>e===o||e.startsWith(o+" ")))return!1;const s=xt.some(o=>t.includes(o)),n=_t.some(o=>t.includes(o)),r=s&&(n||t.length>20);return r&&Tt.info("Heuristic: needsTools=true (action+context or long prompt)"),r}dispose(){}}const St=new Et;class Pt{constructor(t){this.toolRegistry=t,this.enhancers=[]}addEnhancer(t){this.enhancers.push(t)}async getSysPrompt(t,e){let s=t.sysPrompt;if(typeof s=="function"&&(s=s()),!s||typeof s!="string")throw new Error(`Agent "${t.role}" is missing a system prompt.`);const n=[...t.promptEnhancers||[],...this.enhancers,...this.getContributedEnhancers()].sort((o,a)=>(a.priority||0)-(o.priority||0));let r=s;for(const o of n)try{const a=await o.enhance(r,e);a&&typeof a=="string"&&(r=a)}catch(a){console.warn("[PromptBuilder] Enhancer failed:",a)}return r}rewriteChatHistoryForAgent(t,e){return t.map(s=>s.role==="user"?{role:s.role,content:s.content}:s.role===e?{role:"assistant",content:s.content}:{role:"user",content:`***Agent '${s.role}' replied:***
${s.content}`})}getContributedEnhancers(){return L.getContributions(dt).map(e=>({...e.enhancer,priority:e.priority??e.enhancer.priority}))}async build(t,e,s,n){n?.beforeSend&&await n.beforeSend(e,s);const r=B(e),o=this.rewriteChatHistoryForAgent(r,t.role);let a=t.tools;typeof a=="function"&&(a=await a());let c;if(a?.enabled)if(a.smartToolDetection){const h=e[e.length-1];St.needsTools(h?.content||"")&&(c=this.toolRegistry.getAvailableTools(s,a.commandFilter))}else c=this.toolRegistry.getAvailableTools(s,a.commandFilter);const l=await this.getSysPrompt(t,s);return o.unshift({role:"system",content:l}),{messages:o,userPromptIndex:o.length-1,tools:c}}}class bt{constructor(){this.processors=[]}addProcessor(t){this.processors.push(t)}async process(t,e,s){const n=[...e.messageProcessors||[],...this.processors].sort((o,a)=>(a.priority||0)-(o.priority||0));let r={...t};for(const o of n)r=await o.process(r,s);return r}}class Ot{constructor(){this.accumulatedToolCalls=new Map,this.toolCallIndexMap=new Map}processChunk(t){if(!(t.type!=="token"||!t.toolCalls?.length))for(const e of t.toolCalls){const s=e._index,n=e.id;let r,o;s!==void 0&&this.toolCallIndexMap.has(s)?(o=this.toolCallIndexMap.get(s),r=this.accumulatedToolCalls.get(o)):n&&this.accumulatedToolCalls.has(n)?(o=n,r=this.accumulatedToolCalls.get(o)):(o=n||`call_${s!==void 0?s:Date.now()}_${Math.random()}`,r=void 0),r?(this.accumulatedToolCalls.set(o,{id:o,type:e.type||r.type,function:{name:e.function.name||r.function.name,arguments:(r.function.arguments||"")+(e.function.arguments||"")}}),s!==void 0&&!this.toolCallIndexMap.has(s)&&this.toolCallIndexMap.set(s,o)):(this.accumulatedToolCalls.set(o,{...e,id:o}),s!==void 0&&this.toolCallIndexMap.set(s,o))}}getFinalToolCalls(){return Array.from(this.accumulatedToolCalls.values()).filter(t=>t.function.name?.trim().length>0).map(t=>({...t,function:{...t.function,arguments:t.function.arguments?.trim()||"{}"}}))}reset(){this.accumulatedToolCalls.clear(),this.toolCallIndexMap.clear()}}function O(i){return i.replace(/[^a-zA-Z0-9_-]/g,"_").replace(/^[^a-zA-Z]/,"cmd_$&").replace(/_+/g,"_").replace(/^_|_$/g,"")}class Rt{findCommand(t,e){const s=t.function.name,n=_.getCommand(s);if(n)return n;const r=_.listCommands();for(const[o,a]of Object.entries(r))if(O(o)===s)return a;return null}parseArguments(t){if(!t?.trim()||t==="{}")return{};try{const e=JSON.parse(t);return e&&typeof e=="object"?e:{}}catch{return{}}}sanitizeArguments(t,e){if(!e?.parameters||!t||typeof t!="object")return t||{};const s={};return e.parameters.forEach(n=>{const r=O(n.name);r in t&&(s[n.name]=t[r])}),s}async executeToolCall(t,e){try{const s=this.findCommand(t,e),n=s?.id||t.function.name,r=this.parseArguments(t.function.arguments||"{}"),o=this.sanitizeArguments(r,s),a=_.createExecutionContext(o),c={...e,...a,params:o},l=await _.execute(n,c),d={success:!0,message:`Command "${s?.name||n}" executed successfully`,command:n};if(Object.keys(o).length>0&&(d.parameters=o),l!=null){let f=l;f instanceof Promise&&(f=await f),d.result=f,s?.output?.length&&(d.output=s.output.map(m=>`${m.name}: ${m.description||m.type||"value"}`).join(", "))}return{id:t.id,result:d}}catch(s){let n=null;try{n=this.findCommand(t,e)}catch{}const r=s instanceof Error?s.message:String(s),o=n?.name||t.function.name;let a=r;return(r.includes("No handler found")||r.includes("No handlers registered"))&&(a=`Command "${o}" cannot be executed. ${r}.`),{id:t.id,result:null,error:a}}}async executeToolCalls(t,e){const s=[];for(const n of t)s.push(await this.executeToolCall(n,e));return s}createToolCallAccumulator(){return new Ot}createToolCallSignature(t){let e={};try{const n=JSON.parse(t.function.arguments||"{}");e=n&&typeof n=="object"?n:{}}catch{e={}}const s=Object.keys(e).sort().reduce((n,r)=>(n[r]=e[r],n),{});return`${t.function.name}:${JSON.stringify(s)}`}}class Mt{commandToTool(t,e){const s={},n=[];return t.parameters?.forEach(r=>{const o=O(r.name);s[o]={type:r.type||"string",description:r.description,...r.allowedValues&&{enum:r.allowedValues}},r.required===!0&&n.push(o)}),{type:"function",function:{name:O(t.id),description:t.description||t.name,parameters:{type:"object",properties:s,required:n}}}}getAvailableTools(t,e){const s=_.listCommands();let n=Object.values(s);return e&&(n=n.filter(r=>e(r,t))),n.map(r=>this.commandToTool(r,t))}}class It{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");await Promise.all(t.map(async o=>{try{await n(o,e.chatContext.history,s.sharedState,r,e,s)}catch(a){const c=a instanceof Error?a:new Error(String(a));s.errors.set(o.role,c),e.onAgentError?.(o.role,c)}}))}}class K{createAgentContextWithPreviousAgents(t,e,s){return{...t,...e.callContext.getProxy(),previousAgents:Array.from(s.messages.entries()).map(([n,r])=>({role:n,content:r.content}))}}updateWorkflowState(t,e,s,n,r){return e.push(t),s={...s,...n,message:t},r.sharedState=s,{currentMessages:e,accumulatedState:s}}}class Dt extends K{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");let o=[...e.chatContext.history],a={...s.sharedState};for(const c of t)try{const l=this.createAgentContextWithPreviousAgents(a,e,s),h=await n(c,o,a,r,e,s);if(!h)break;const d=this.updateWorkflowState(h,o,a,l,s);o=d.currentMessages,a=d.accumulatedState}catch(l){const h=l instanceof Error?l:new Error(String(l));s.errors.set(c.role,h),e.onAgentError?.(c.role,h);break}}}class Nt extends K{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");let o=[...e.chatContext.history],a={...s.sharedState};for(const c of t)try{const l=this.createAgentContextWithPreviousAgents(a,e,s);if(c.canHandle&&!c.canHandle(l))continue;const h=await n(c,o,a,r,e,s);if(!h)break;const d=this.updateWorkflowState(h,o,a,l,s);o=d.currentMessages,a=d.accumulatedState}catch(l){const h=l instanceof Error?l:new Error(String(l));s.errors.set(c.role,h),e.onAgentError?.(c.role,h)}}}class $t{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");let o=[...e.chatContext.history];for(const a of this.buildTopoOrder(t)){await Promise.all(a.map(async c=>{try{await n(c,o,s.sharedState,r,e,s)}catch(l){const h=l instanceof Error?l:new Error(String(l));s.errors.set(c.role,h),e.onAgentError?.(c.role,h)}}));for(const c of a){const l=s.messages.get(c.role);l&&o.push(l)}}}buildTopoOrder(t){const e=[],s=new Set;for(;s.size<t.length;){const n=t.filter(r=>{if(s.has(r.role))return!1;if(!r.consumes?.length)return!0;const o=t.filter(a=>s.has(a.role)).flatMap(a=>a.produces||[]);return r.consumes.every(a=>o.includes(a))});if(n.length===0){e.push(t.filter(r=>!s.has(r.role)));break}e.push(n);for(const r of n)s.add(r.role)}return e}}function U(i,t){const e=Date.now();return{id:`plan-${e}-${Math.random().toString(36).slice(2,9)}`,originalPrompt:i,steps:t.map(s=>({...s,status:"pending",revisions:0})),status:"planning",createdAt:e,updatedAt:e}}function Lt(i){const t=new Set(i.steps.filter(e=>e.status==="completed").map(e=>e.id));return i.steps.filter(e=>e.status==="pending"&&e.dependsOn.every(s=>t.has(s)))}function qt(i){return i.steps.every(t=>t.status==="completed"||t.status==="skipped")}function Wt(i){return i.steps.some(t=>t.status==="failed")}const Ft=`You are a task orchestrator. Given a user's complex request, decompose it into a structured execution plan.

Respond with ONLY a JSON object matching this schema (no markdown, no explanation):
{
  "steps": [
    {
      "id": "step-1",
      "role": "<agent role>",
      "subTask": "<specific instruction for this step>",
      "dependsOn": [],
      "consumes": [],
      "produces": ["<artifact-id>"]
    }
  ]
}

Rules:
- Each step must have a unique id (step-1, step-2, ...)
- "role" must match an available agent role
- "dependsOn" lists step IDs that must complete before this step
- "consumes" and "produces" are artifact IDs
- Steps with no dependencies can run in parallel
- Keep the plan minimal â€” only as many steps as needed`;async function z(i){const t=i.availableAgents.filter(n=>!n.isOrchestrator).map(n=>`- ${n.role}: ${n.description}`).join(`
`),e=[{role:"system",content:`${Ft}

Available agents:
${t}`},{role:"user",content:i.prompt}],s=await i.executeCompletion(e,i.chatConfig);try{const n=s.match(/\{[\s\S]*\}/);if(!n)throw new Error("No JSON found in orchestrator response");const r=JSON.parse(n[0]);return U(i.prompt,r.steps||[])}catch{const r=i.availableAgents.find(o=>!o.isOrchestrator);return U(i.prompt,[{id:"step-1",role:r?.role||ht,subTask:i.prompt,dependsOn:[],consumes:[],produces:["step-1-result"]}])}}class S{constructor(t,e){this.artifacts=new Map,this.mailbox=new Map,this.taskId=t,this.plan=e}putArtifact(t){this.artifacts.set(t.id,t)}getArtifact(t){return this.artifacts.get(t)}getArtifactsByType(t){return Array.from(this.artifacts.values()).filter(e=>e.type===t)}getArtifactsProducedBy(t){return Array.from(this.artifacts.values()).filter(e=>e.producedBy===t)}postMessage(t){const e=t.to==="*"?"__broadcast__":t.to,s=this.mailbox.get(e)||[];s.push(t),this.mailbox.set(e,s)}readMessages(t){const e=this.mailbox.get(t)||[],s=this.mailbox.get("__broadcast__")||[];return[...e,...s]}clearMessages(t){this.mailbox.delete(t)}updateStepStatus(t,e,s){const n=this.plan.steps.find(r=>r.id===t);n&&(n.status=e,s&&(n.result=s,this.putArtifact(s)),this.plan.updatedAt=Date.now())}getNextRunnableSteps(){const t=new Set(this.plan.steps.filter(e=>e.status==="completed").map(e=>e.id));return this.plan.steps.filter(e=>e.status==="pending"&&e.dependsOn.every(s=>t.has(s)))}toJSON(){return{taskId:this.taskId,plan:this.plan,artifacts:Array.from(this.artifacts.values()),mailbox:Object.fromEntries(this.mailbox.entries())}}static fromJSON(t){const e=new S(t.taskId,t.plan);for(const s of t.artifacts||[])e.artifacts.set(s.id,s);for(const[s,n]of Object.entries(t.mailbox||{}))e.mailbox.set(s,n);return e}}const D="ai_task_checkpoint_",N="ai_task_checkpoint_registry";class Ht{async save(t){const e=`${D}${t.taskId}`;await w.set(e,t.toJSON())}async restore(t){const e=`${D}${t}`,s=await w.get(e);return s?S.fromJSON(s):null}async delete(t){const e=`${D}${t}`;await w.set(e,void 0)}async listCheckpoints(){return this.getRegistry()}async registerCheckpoint(t){const e=await this.getRegistry();e.includes(t)||(e.push(t),await w.set(N,e))}async unregisterCheckpoint(t){const e=await this.getRegistry();await w.set(N,e.filter(s=>s!==t))}async getRegistry(){return await w.get(N)||[]}}const E=new Ht;class ${constructor(t){this.executeStep=t}async run(t,e){const s=t.plan;s.status="running",await E.save(t);const n=new Map;for(;;){if(e.signal?.aborted){s.status="paused";break}const o=Lt(s);if(o.length===0)break;if(await Promise.all(o.map(async a=>{t.updateStepStatus(a.id,"running"),e.onStepStart?.(a);try{const c=await this.executeStep(a,t,e);t.updateStepStatus(a.id,"completed",c),e.onStepComplete?.(a,c),await E.save(t)}catch(c){const l=c instanceof Error?c:new Error(String(c));t.updateStepStatus(a.id,"failed"),n.set(a.id,l),e.onStepError?.(a,l)}})),Wt(s)){s.status="failed";break}if(qt(s)){s.status="completed";break}}const r=s.steps.filter(o=>o.result).map(o=>o.result);return{plan:s,artifacts:r,errors:n}}}class Ut{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");const o=e.chatContext.history[e.chatContext.history.length-1]?.content||"",a=new W,c=await z({prompt:o,availableAgents:t,chatConfig:r,context:e.callContext.getProxy(),executeCompletion:(u,y)=>q(u,y,a)}),l=new S(`wf-${Date.now()}`,c),h=new Map(t.map(u=>[u.role,u])),m=(await new $(async(u,y,p)=>{const C=h.get(u.role)||t[0],k=[...e.chatContext.history,{role:"user",content:u.subTask}],M=(await n(C,k,s.sharedState,r,e,s))?.content||"";return{id:u.produces[0]||`${u.id}-result`,type:"text",content:M,producedBy:u.role,createdAt:Date.now()}}).run(l,{prompt:o,chatConfig:r,callContext:e.callContext,signal:e.signal})).artifacts.map(u=>u.content).filter(Boolean).join(`

`);m&&s.messages.set("orchestrator",{role:"assistant",content:m})}}const Gt=`You are a quality reviewer. Evaluate the provided artifact against the original task.

Respond with ONLY a JSON object:
{
  "verdict": "approved" | "needs-revision",
  "score": 0-100,
  "notes": "<feedback for revision, empty if approved>"
}`;async function jt(i){const t=[{role:"system",content:Gt},{role:"user",content:`Original task: ${i.originalTask}

Artifact to review:
${i.artifact.content}`}];try{const s=(await i.executeCompletion(t,i.chatConfig)).match(/\{[\s\S]*\}/);if(!s)throw new Error("No JSON in reviewer response");const n=JSON.parse(s[0]);return{verdict:n.verdict==="approved"?"approved":"needs-revision",score:typeof n.score=="number"?n.score:50,notes:n.notes||""}}catch{return{verdict:"approved",score:70,notes:""}}}class Jt{async execute(t,e,s,n){const r=e.chatConfig;if(!r)throw new Error("Chat config is required");const o=new W,a=t[0],c=t.find(f=>f.reviewerFor?.includes(a.role)),l=a.maxRevisions??2;let h=[...e.chatContext.history],d=0;for(;d<=l;){const f=await n(a,h,s.sharedState,r,e,s);if(!f)break;if(!c){s.messages.set(a.role,f);break}const m={id:`draft-${d}`,type:"text",content:f.content,producedBy:a.role,createdAt:Date.now()},u=e.chatContext.history[e.chatContext.history.length-1]?.content||"",y=await jt({artifact:m,originalTask:u,chatConfig:r,executeCompletion:(p,C)=>q(p,C,o)});if(y.verdict==="approved"||d>=l){s.messages.set(a.role,f);break}h=[...e.chatContext.history,f,{role:"user",content:`Please revise based on this feedback: ${y.notes}`}],d++}}}class Bt{constructor(){this.strategies=new Map([["parallel",new It],["sequential",new Dt],["conditional",new Nt],["pipeline",new $t],["orchestrated",new Ut],["review",new Jt]])}registerStrategy(t,e){this.strategies.set(t,e)}async execute(t,e,s){const n=`workflow-${Date.now()}-${Math.random()}`,r=e.execution||"parallel",o={messages:new Map,sharedState:{...e.sharedState||{}},errors:new Map};v(at,{workflowId:n,options:e});try{const a=this.strategies.get(r);if(!a)throw new Error(`Unknown workflow execution strategy: ${r}`);return await a.execute(t,e,o,s),v(it,{workflowId:n,results:o}),o}catch(a){const c=a instanceof Error?a:new Error(String(a));throw v(ct,{workflowId:n,error:c}),c}}}const T=class T{static estimateTokens(t){if(!t?.trim())return 0;const e=t.trim();return Math.max(1,Math.ceil(e.length/this.AVERAGE_CHARS_PER_TOKEN+e.split(/\s+/).filter(s=>s.length>0).length*.3))}static estimateMessageTokens(t){let e=this.MESSAGE_OVERHEAD;if(t.content&&(e+=this.estimateTokens(t.content)),t.role&&(e+=this.estimateTokens(t.role)),t.tool_calls)for(const s of t.tool_calls)e+=this.estimateTokens(s.function.name||"")+this.estimateTokens(s.function.arguments||"{}")+this.TOOL_CALL_OVERHEAD;return t.tool_call_id&&(e+=this.estimateTokens(t.tool_call_id)),e}static estimatePromptTokens(t,e){let s=t.reduce((n,r)=>n+this.estimateMessageTokens(r),0);if(e?.length)for(const n of e)s+=this.TOOL_DEFINITION_OVERHEAD,s+=this.estimateTokens(n.function.name||""),s+=this.estimateTokens(n.function.description||""),n.function.parameters&&(s+=this.estimateTokens(JSON.stringify(n.function.parameters)));return s}static estimateCompletionTokens(t,e){let s=this.estimateTokens(t);if(e?.length)for(const n of e)s+=this.TOOL_CALL_OVERHEAD+this.estimateTokens(n.function?.name||"")+this.estimateTokens(n.function?.arguments||"{}");return s}};T.AVERAGE_CHARS_PER_TOKEN=4,T.TOOL_DEFINITION_OVERHEAD=50,T.TOOL_CALL_OVERHEAD=10,T.MESSAGE_OVERHEAD=4;let R=T;const G="ai_token_usage",x={promptTokens:0,completionTokens:0,totalTokens:0,requestCount:0};class Kt{constructor(){this.data=null,this.loadPromise=null}async loadData(){return this.data?this.data:this.loadPromise?this.loadPromise:(this.loadPromise=(async()=>{const t=await H.getObject(G);return this.data=t||{providers:{},total:{...x},lastUpdated:Date.now()},this.data||(this.data={providers:{},total:{...x},lastUpdated:Date.now()},await this.saveData()),this.loadPromise=null,this.data})(),this.loadPromise)}async saveData(){this.data&&(this.data.lastUpdated=Date.now(),await H.persistObject(G,this.data))}async recordUsage(t,e){if(await this.loadData(),!this.data)return;this.data.providers[t]??={...x};const s=this.data.providers[t];s.promptTokens+=e.promptTokens,s.completionTokens+=e.completionTokens,s.totalTokens+=e.totalTokens,s.requestCount+=1,this.data.total.promptTokens+=e.promptTokens,this.data.total.completionTokens+=e.completionTokens,this.data.total.totalTokens+=e.totalTokens,this.data.total.requestCount+=1,await this.saveData()}async getProviderUsage(t){return await this.loadData(),this.data?.providers[t]||null}async getAllProviderUsage(){return await this.loadData(),this.data?.providers||{}}async getTotalUsage(){return await this.loadData(),this.data?.total||{...x}}async reset(){this.data={providers:{},total:{...x},lastUpdated:Date.now()},await this.saveData()}async resetProvider(t){if(await this.loadData(),!this.data)return;const e=this.data.providers[t];e&&(this.data.total.promptTokens-=e.promptTokens,this.data.total.completionTokens-=e.completionTokens,this.data.total.totalTokens-=e.totalTokens,this.data.total.requestCount-=e.requestCount,delete this.data.providers[t],await this.saveData())}}const zt=new Kt;class Vt{constructor(){this.activeRequests=new Map,this.activeTasks=new Map,this.toolRegistry=new Mt,this.providerFactory=new W,this.agentRegistry=new vt,this._promptBuilder=new Pt(this.toolRegistry),this.messageProcessor=new bt,this.toolExecutor=new Rt,this.workflowEngine=new Bt,Q(tt,()=>{this.aiConfig=void 0,this.configCheckPromise=void 0,this.checkAIConfig().then()}),this.checkAIConfig().then()}get promptBuilder(){return this._promptBuilder}getAgentContributions(){return this.agentRegistry.getAgentContributions()}async getProviders(){return await this.checkAIConfig(),this.aiConfig?.providers||[]}async getDefaultProvider(){await this.checkAIConfig();const t=await this.getProviders();if(this.aiConfig?.defaultProvider){const e=t.find(s=>s.name===this.aiConfig?.defaultProvider);if(e)return e}return t[0]}async setDefaultProvider(t){return await this.checkAIConfig(),this.aiConfig&&(this.aiConfig.defaultProvider=t,await w.set(A,this.aiConfig)),this.getDefaultProvider()}createMessage(t){return{role:"user",content:t}}registerStreamingFetcher(t){this.providerFactory.registerProvider(t)}getContributedProviders(){return L.getContributions(ut).map(e=>e.provider)}mergeProviders(t,e){const s=new Set(t.map(r=>r.name)),n=e.filter(r=>!s.has(r.name));return n.length>0?[...t,...n]:t}async createInitialConfig(){const t={...ft,providers:this.getContributedProviders()};return await w.set(A,t),w.get(A)}async updateConfigWithMissingProviders(t){const e=this.mergeProviders(t.providers,this.getContributedProviders());if(e.length===t.providers.length)return t;const s={...t,providers:e};return await w.set(A,s),s}async checkAIConfig(){if(!this.aiConfig)return this.configCheckPromise?this.configCheckPromise:(this.configCheckPromise=this.performConfigCheck(),this.configCheckPromise)}async performConfigCheck(){try{this.aiConfig=await w.get(A),this.aiConfig=this.aiConfig?await this.updateConfigWithMissingProviders(this.aiConfig):await this.createInitialConfig(),v(ot,this.aiConfig)}finally{this.configCheckPromise=void 0}}createAgentContext(t,e,s={}){return{...t,...e.getProxy(),...s}}async*streamCompletion(t){const e=`${Date.now()}-${Math.random()}`,s=new AbortController;this.activeRequests.set(e,s),t.signal&&t.signal.addEventListener("abort",()=>s.abort());const n=t.signal||s.signal;try{t.onStatus?.("starting"),v(st,{requestId:e,options:t});const r=t.chatConfig||await this.getDefaultProvider(),o=B(t.chatContext.history),a=this.providerFactory.getProvider(r),c=this.toolExecutor.createToolCallAccumulator();let l="",h="assistant",d;for await(const u of a.stream({model:r.model,messages:o,chatConfig:r,tools:t.tools,signal:n})){if(u.type==="error"){t.onStatus?.("error"),v(I,{requestId:e,chunk:u}),yield u;break}if(u.type==="token")c.processChunk(u),u.toolCalls?.length||(l+=u.content),u.message?.role&&(h=u.message.role),u.content&&t.onToken?.(u.content),t.onStatus?.("streaming"),t.onProgress?.({received:l.length}),v(rt,{requestId:e,chunk:u}),yield u;else if(u.type==="done"){u.metadata?.usage&&(d=u.metadata.usage),t.onStatus?.("complete"),v(nt,{requestId:e}),yield u;break}else yield u}const f=c.getFinalToolCalls(),m={role:h,content:l,...f.length>0&&{toolCalls:f}};if(!d){const u=R.estimatePromptTokens(o,t.tools),y=R.estimateCompletionTokens(l,f);d={promptTokens:u,completionTokens:y,totalTokens:u+y,estimated:!0}}return zt.recordUsage(r.name,d).catch(u=>{et.error(`Failed to record token usage: ${u instanceof Error?u.message:String(u)}`)}),{message:m,tokenUsage:d}}catch(r){if(r instanceof Error&&r.name==="AbortError")throw t.onStatus?.("error"),v(I,{requestId:e,error:"Request cancelled"}),r;t.onStatus?.("error");const o=r instanceof Error?r.message:String(r);throw v(I,{requestId:e,error:o}),yield{type:"error",content:o,metadata:{error:r}},r}finally{this.activeRequests.delete(e)}}async handleStreamingPromptDirect(t){const e=this.streamCompletion(t);let s;for(;;){if(s=await e.next(),s.done)return s.value.message;const n=s.value;if(n.type==="error")throw new Error(n.content);if(n.type==="done"){const r=await e.next();if(r.done&&r.value)return r.value.message;if(!r.done)continue;throw new Error("Stream completed without return value")}}}async handleStreamingPrompt(t){const e=t.callContext||b.createChild({}),s=this.createAgentContext({},e,{userPrompt:t.chatContext.history[t.chatContext.history.length-1]?.content||""}),n=this.agentRegistry.getMatchingAgents(s),r=n.length>0?n.map(c=>c.role):["assistant"],o=await this.executeAgentWorkflow({chatContext:t.chatContext,chatConfig:t.chatConfig,callContext:e,execution:"parallel",stream:t.stream,signal:t.signal,onToken:(c,l)=>t.onToken?.(l),onStatus:(c,l)=>t.onStatus?.(l),roles:r}),a=Array.from(o.messages.values());return a.length===1?a[0]:a}cancelRequest(t){const e=this.activeRequests.get(t);return e?(e.abort(),this.activeRequests.delete(t),!0):!1}async executeAgentWorkflow(t){const e=this.createAgentContext(t.sharedState||{},t.callContext),s=this.agentRegistry.getMatchingAgents(e,t.roles);return this.workflowEngine.execute(s,t,(n,r,o,a,c,l)=>this.executeAgent(n,r,o,a,c,l))}async executeAgent(t,e,s,n,r,o){r.onAgentStart?.(t.role);const a=this.createAgentContext(s,r.callContext,{userPrompt:e[e.length-1]?.content||""}),{messages:c,tools:l}=await this._promptBuilder.build(t,e,a,t.hooks),h=c.map(p=>{const C={role:p.role,content:p.content};return p.tool_call_id&&(C.tool_call_id=p.tool_call_id),p.tool_calls&&(C.tool_calls=p.tool_calls),C});let d=await this.handleStreamingPromptDirect({chatContext:{history:h},chatConfig:n,callContext:r.callContext,stream:r.stream??!0,signal:r.signal,onToken:r.onToken?p=>r.onToken(t.role,p):void 0,tools:l}),f=0;const m=[...c];for(;d.toolCalls&&d.toolCalls.length>0;){if(f++,f>gt){console.warn("[AIService] Max tool call iterations reached");break}let p;if(r.requireToolApproval&&r.onToolApprovalRequest){const g=d.toolCalls.map(P=>{let F={};try{F=JSON.parse(P.function.arguments||"{}")}catch{}return`${P.function.name}(${Object.entries(F).map(([Y,X])=>`${Y}=${X}`).join(", ")})`}).join(", "),M={toolCalls:d.toolCalls,message:`The AI wants to execute: ${g}`};await r.onToolApprovalRequest(t.role,M)?p=await this.toolExecutor.executeToolCalls(d.toolCalls,a):p=d.toolCalls.map(P=>({id:P.id,result:{success:!1,message:"Tool execution cancelled by user",cancelled:!0}}))}else p=await this.toolExecutor.executeToolCalls(d.toolCalls,a);const C=p.map(g=>({role:"tool",content:g.error?JSON.stringify({error:g.error}):JSON.stringify(g.result),tool_call_id:g.id})),k={role:"assistant",content:d.content||""};if(d.toolCalls?.length&&(k.tool_calls=d.toolCalls.filter(g=>g.function.name?.trim()).map(g=>({id:g.id,type:g.type,function:{name:g.function.name,arguments:g.function.arguments||"{}"}}))),m.push(k,...C),d=await this.handleStreamingPromptDirect({chatContext:{history:m.map(g=>({role:g.role,content:g.content,...g.tool_call_id&&{tool_call_id:g.tool_call_id},...g.tool_calls&&{tool_calls:g.tool_calls}}))},chatConfig:n,callContext:r.callContext,stream:r.stream??!0,signal:r.signal,tools:l}),d.content?.trim()&&!d.toolCalls?.length)break}const u=await this.messageProcessor.process(d,t,this.createAgentContext(s,r.callContext,{message:d}));t.hooks?.afterReceive&&await t.hooks.afterReceive(u,this.createAgentContext(s,r.callContext));const y={role:t.role,content:u.content};return o.messages.set(t.role,y),r.onAgentComplete?.(t.role,y),y}async planTask(t,e){const s=await this.getDefaultProvider(),n=this.agentRegistry.getAgentContributions();return b.createChild({}),z({prompt:t,availableAgents:n,chatConfig:s,context:e,executeCompletion:(r,o)=>q(r,o,this.providerFactory)})}async executeTask(t){const e=t.chatConfig||await this.getDefaultProvider(),s=t.callContext||b.createChild({}),n=this.agentRegistry.getAgentContributions(),r=await this.planTask(t.prompt,s.getProxy());t.onPlanReady?.(r);const o=new S(`task-${Date.now()}`,r);await E.registerCheckpoint(o.taskId);const a=new AbortController;this.activeTasks.set(o.taskId,a);const c={...t,signal:t.signal??a.signal},l=new Map(n.map(d=>[d.role,d])),h=new $(this.createStepExecutor(l,n,e,s,c));try{const d=await h.run(o,c);return await E.unregisterCheckpoint(o.taskId),d}finally{this.activeTasks.delete(o.taskId)}}async resumeTask(t,e){const s=await E.restore(t);if(!s)throw new Error(`No checkpoint found for task ${t}`);const n=e.chatConfig||await this.getDefaultProvider(),r=e.callContext||b.createChild({}),o=this.agentRegistry.getAgentContributions(),a=new Map(o.map(l=>[l.role,l]));return new $(this.createStepExecutor(a,o,n,r,e)).run(s,e)}createStepExecutor(t,e,s,n,r){return async(o,a,c)=>{const l=t.get(o.role)||e[0],h=[...r.chatContext?.history||[],{role:"user",content:o.subTask}],f=(await this.workflowEngine.execute([l],{chatContext:{history:h},chatConfig:s,callContext:n,execution:"parallel",stream:!0,signal:r.signal,roles:[l.role]},(m,u,y,p,C,k)=>this.executeAgent(m,u,y,p,C,k))).messages.get(l.role);return{id:o.produces[0]||`${o.id}-result`,type:"text",content:f?.content||"",producedBy:o.role,createdAt:Date.now()}}}cancelTask(t){const e=this.activeTasks.get(t);e&&(e.abort(),this.activeTasks.delete(t))}}const Xt=new Vt;export{dt as C,x as E,A as K,W as P,ot as T,Xt as a,ut as b,nt as c,lt as d,Mt as e,zt as t};
