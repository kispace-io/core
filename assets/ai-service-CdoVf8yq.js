import{a as b,c as k,x as oe,J as C,a6 as $,s as ne,f as se,g as v,q as re,k as ae}from"./main-CymV4qDG.js";import{i as ie,M as le,a as ce}from"./in-browser-ml-service-D7AoKjy9.js";const N="events/aiservice/streamStarted",F="events/aiservice/streamChunk",L="events/aiservice/streamComplete",x="events/aiservice/streamError",z="events/aiservice/aiConfigChanged",U="events/aiservice/agentWorkflowStarted",W="events/aiservice/agentWorkflowComplete",H="events/aiservice/agentWorkflowError",j="aiservice.agents",G="aiservice.chatProviders",K="aiservice.promptEnhancers",A="aiConfig",J={defaultProvider:"openai",providers:[]},M=10,Re=Object.freeze(Object.defineProperty({__proto__:null,AI_CONFIG_TEMPLATE:J,CID_AGENTS:j,CID_CHAT_PROVIDERS:G,CID_PROMPT_ENHANCERS:K,KEY_AI_CONFIG:A,MAX_TOOL_ITERATIONS:M,TOPIC_AGENT_WORKFLOW_COMPLETE:W,TOPIC_AGENT_WORKFLOW_ERROR:H,TOPIC_AGENT_WORKFLOW_STARTED:U,TOPIC_AICONFIG_CHANGED:z,TOPIC_AI_STREAM_CHUNK:F,TOPIC_AI_STREAM_COMPLETE:L,TOPIC_AI_STREAM_ERROR:x,TOPIC_AI_STREAM_STARTED:N},Symbol.toStringTag,{value:"Module"}));class B{constructor(){this.decoder=new TextDecoder}*processLines(e){for(const t of e)t.trim()!==""&&(yield t)}}class ue extends B{constructor(){super(...arguments),this.usage=null}async*parse(e){let t="";this.usage=null;try{for(;;){const{done:s,value:n}=await e.read();if(s)break;t+=this.decoder.decode(n,{stream:!0});const r=t.split(`
`);t=r.pop()||"";for(const i of this.processLines(r))if(i.startsWith("data: ")){const a=i.slice(6).trim();if(a==="[DONE]"){const l={type:"done",content:""};this.usage&&(l.metadata={usage:this.usage}),yield l;continue}try{const l=JSON.parse(a);if(l.error){yield{type:"error",content:l.error.message||"Unknown error",metadata:l.error};continue}this.extractUsage(l);const d=this.parseChunk(l);d&&(yield d)}catch{continue}}}if(t.trim()&&t.startsWith("data: ")){const s=t.slice(6).trim();if(s!=="[DONE]")try{const n=JSON.parse(s);this.extractUsage(n);const r=this.parseChunk(n);r&&(yield r)}catch{}}const o={type:"done",content:""};this.usage&&(o.metadata={usage:this.usage}),yield o}finally{e.releaseLock()}}extractUsage(e){if(e.usage){const t=e.usage;this.usage={promptTokens:t.prompt_tokens||0,completionTokens:t.completion_tokens||0,totalTokens:t.total_tokens||0,estimated:!1}}}parseChunk(e){const t=e.choices?.[0]?.delta,o=e.choices?.[0];if(t?.content)return{type:"token",content:t.content,message:{role:t.role||"assistant",content:o?.message?.content||t.content}};if(o?.message?.tool_calls){const s=this.parseToolCalls(o.message.tool_calls,!0);if(s.length>0)return{type:"token",content:"",toolCalls:s}}else if(t?.tool_calls||o?.delta?.tool_calls){const s=this.parseToolCalls(t?.tool_calls||o?.delta?.tool_calls||[],!1);if(s.length>0)return{type:"token",content:"",toolCalls:s}}return null}parseToolCalls(e,t=!1){return e.filter(o=>o.function!==void 0).map((o,s)=>({id:o.id||`call_${o.index!==void 0?o.index:s}_${Date.now()}`,type:"function",function:{name:o.function?.name||"",arguments:o.function?.arguments||(t?"{}":"")},_index:o.index!==void 0?o.index:s}))}}class de extends B{constructor(){super(...arguments),this.usage=null}async*parse(e){let t="";this.usage=null;try{for(;;){const{done:s,value:n}=await e.read();if(s)break;t+=this.decoder.decode(n,{stream:!0});const r=t.split(`
`);t=r.pop()||"";for(const i of this.processLines(r))try{const a=JSON.parse(i);if(a.error){yield{type:"error",content:a.error,metadata:a};continue}if(a.done){this.extractUsage(a);const l={type:"done",content:""};this.usage&&(l.metadata={usage:this.usage}),yield l;continue}a.message?.content?yield{type:"token",content:a.message.content,message:{role:a.message.role||"assistant",content:a.message.content}}:a.response&&(yield{type:"token",content:a.response,message:{role:"assistant",content:a.response}})}catch{continue}}if(t.trim())try{const s=JSON.parse(t);s.done&&this.extractUsage(s),s.message?.content&&(yield{type:"token",content:s.message.content,message:{role:s.message.role||"assistant",content:s.message.content}})}catch{}const o={type:"done",content:""};this.usage&&(o.metadata={usage:this.usage}),yield o}finally{e.releaseLock()}}extractUsage(e){if(e.prompt_eval_count!==void 0||e.eval_count!==void 0){const t=e.prompt_eval_count||0,o=e.eval_count||0;this.usage={promptTokens:t,completionTokens:o,totalTokens:t+o,estimated:!1}}}}class V{createParser(e,t){return e.includes("text/event-stream")||t.includes("openai")?new ue:new de}async getAvailableModels(e){if(!e.chatApiEndpoint)return[];try{const t=e.chatApiEndpoint;let o=t;if(t.includes("/v1/chat/completions"))o=t.replace("/v1/chat/completions","");else if(t.includes("/api/v1/chat/completions"))o=t.replace("/api/v1/chat/completions","");else if(t.includes("/api/chat/completion"))o=t.replace("/api/chat/completion","");else try{const l=new URL(t);o=`${l.protocol}//${l.host}`}catch{return[]}const s=`${o}/v1/models`,n={"Content-Type":"application/json"};e.apiKey&&(n.Authorization=`Bearer ${e.apiKey}`);const r=await fetch(s,{method:"GET",headers:n});return r.ok?((await r.json()).data||[]).map(l=>({id:l.id,name:l.name||l.id})):[]}catch{return[]}}async*stream(e){const t={model:e.model,stream:!0,messages:e.messages,...e.chatConfig.parameters};e.tools&&e.tools.length>0&&(t.tools=e.tools,t.tool_choice="auto");const o=await fetch(e.chatConfig.chatApiEndpoint,{method:"POST",headers:{Authorization:`Bearer ${e.chatConfig.apiKey}`,"Content-Type":"application/json",Accept:"text/event-stream"},body:JSON.stringify(t),signal:e.signal});if(!o.ok){const a=await o.text().catch(()=>"Unknown error");yield{type:"error",content:`HTTP ${o.status}: ${a}`,metadata:{status:o.status,statusText:o.statusText}};return}const s=o.headers.get("content-type")||"",n=o.headers.get("content-length");if(!o.body){yield{type:"error",content:`Response body is null or empty (Content-Length: ${n||"unknown"}). This may indicate: 1) The endpoint doesn't support streaming, 2) Authentication is required/invalid, 3) The endpoint URL is incorrect. For Open WebUI, ensure you're using the correct endpoint and API key.`,metadata:{status:o.status,contentType:s,contentLength:n,endpoint:e.chatConfig.chatApiEndpoint,hasApiKey:!!e.chatConfig.apiKey}};return}const r=o.body.getReader();if(!r){yield{type:"error",content:"Response body is not readable"};return}const i=this.createParser(s,e.chatConfig.chatApiEndpoint);try{for await(const a of i.parse(r))yield a}catch(a){yield{type:"error",content:a instanceof Error?a.message:"Failed to parse response stream",metadata:{error:a,contentType:s,endpoint:e.chatConfig.chatApiEndpoint}}}}}class he extends V{constructor(){super(...arguments),this.name="openai"}canHandle(e){return e.chatApiEndpoint.includes("openai")||e.chatApiEndpoint.includes("v1/chat/completions")}}class fe extends V{constructor(){super(...arguments),this.name="ollama"}canHandle(e){return e.name.toLowerCase()==="ollama"||e.chatApiEndpoint.includes("ollama")||e.chatApiEndpoint.includes("localhost:11434")}}class ge{constructor(){this.providers=[],this.registerDefaultProviders()}registerDefaultProviders(){this.providers.push(new he),this.providers.push(new fe)}registerProvider(e){this.providers.push(e)}getProvider(e){const t=this.providers.find(o=>o.canHandle(e));return t||this.providers[0]}getAllProviders(){return[...this.providers]}}class me{getAgentContributions(){return b.getContributions(j)}filterAndSortAgents(e,t){return e.filter(o=>o.canHandle?o.canHandle(t):!0).sort((o,s)=>(s.priority||0)-(o.priority||0))}getMatchingAgents(e,t){const o=this.getAgentContributions();if(o.length===0)throw new Error("No agents are registered. The App Support agent should be available from the AI system extension.");let s=o.filter(n=>t&&!t.includes(n.role)?!1:n.canHandle?n.canHandle(e):!0);if(t&&t.length>0){if(s=s.sort((n,r)=>(r.priority||0)-(n.priority||0)),s.length===0){const n=t.join(", ");throw new Error(`No agents found for requested roles: ${n}. Available agents: ${o.map(r=>r.role).join(", ")}`)}}else if(s=this.filterAndSortAgents(s,e),s.length===0)throw new Error(`No agents can handle the current context. Available agents: ${o.map(n=>n.role).join(", ")}`);return s}}class Z{sanitizeFunctionName(e){return e.replace(/[^a-zA-Z0-9_-]/g,"_").replace(/^[^a-zA-Z]/,"cmd_$&").replace(/_+/g,"_").replace(/^_|_$/g,"")}commandToTool(e,t){const o={},s=[];return e.parameters?.forEach(i=>{const a=this.sanitizeFunctionName(i.name);o[a]={type:i.type||"string",description:i.description,...i.allowedValues&&{enum:i.allowedValues}},i.required===!0&&s.push(a)}),{type:"function",function:{name:this.sanitizeFunctionName(e.id),description:e.description||e.name,parameters:{type:"object",properties:o,required:s}}}}getAvailableTools(e,t){const o=k.listCommands();let s=Object.values(o);return t&&(s=s.filter(n=>t(n,e))),s.map(n=>this.commandToTool(n,e))}}const w=oe("ToolDetector");class pe{constructor(){this.classifier=null,this.loading=!1,this.loadPromise=null}async ensureLoaded(){if(!this.classifier)return this.loading&&this.loadPromise?this.loadPromise:(this.loading=!0,this.loadPromise=(async()=>{try{w.info("Loading ML model for tool detection..."),this.classifier=await ie.getPipeline(le.ZERO_SHOT_CLASSIFICATION,ce.ZERO_SHOT_CLASSIFICATION,{quantized:!0}),w.info("ML model loaded successfully - will use for tool detection")}catch(e){const t=e instanceof Error?e.message:String(e);w.warn(`Failed to load ML model, will use keyword-based detection fallback: ${t}`),this.classifier=null}finally{this.loading=!1}})(),this.loadPromise)}async needsTools(e){if(!e||e.trim().length===0)return!1;const t=e.toLowerCase().trim();if(["hello","hi","hey","thanks","thank you","bye","goodbye"].some(n=>t===n||t.startsWith(n+" ")))return!1;try{if(await this.ensureLoaded(),this.classifier){w.info(`Using ML model to classify prompt: "${t.substring(0,50)}${t.length>50?"...":""}"`);const n=await this.classifier(t,["requires executing commands or actions","is a simple greeting or question"]),r=n.labels[0]==="requires executing commands or actions"&&n.scores[0]>.6;return w.info(`ML classification result: ${n.labels[0]} (confidence: ${(n.scores[0]*100).toFixed(1)}%) - needsTools: ${r}`),r}}catch(n){const r=n instanceof Error?n.message:String(n);w.warn(`ML classification failed, using keyword fallback: ${r}`)}w.info("Using keyword-based detection (ML model not available)");const s=this.keywordBasedDetection(t);return w.info(`Keyword detection result: needsTools=${s}`),s}keywordBasedDetection(e){const t=["create","open","delete","read","write","edit","save","rename","move","copy","list","show","display","run","execute","build","add","remove","update","modify","change","set","get","find","search","filter","sort","install","uninstall","load","import","export","generate","make","do","perform","call","invoke"],o=["file","folder","directory","workspace","editor","map","layer","command","tool","extension","script","code","project"],s=t.some(r=>e.includes(r)),n=o.some(r=>e.includes(r));return s&&(n||e.length>20)}dispose(){this.classifier=null,this.loading=!1,this.loadPromise=null}}const ye=new pe;class Ce{constructor(){this.toolRegistry=new Z,this.enhancers=[]}addEnhancer(e){this.enhancers.push(e)}async getSysPrompt(e,t){let o=e.sysPrompt;if(typeof o=="function"&&(o=o()),!o||typeof o!="string")throw new Error(`Agent "${e.role}" (${e.label}) is missing a system prompt. All agents must provide a sysPrompt.`);const s=[...e.promptEnhancers||[],...this.enhancers,...this.getContributedEnhancers()].sort((r,i)=>(i.priority||0)-(r.priority||0));let n=o;for(const r of s)try{n=await r.enhance(n,t),(!n||typeof n!="string")&&(n=o)}catch(i){console.warn("[PromptBuilder] Enhancer failed:",i)}return n}rewriteChatHistoryForAgent(e,t){return e.map(o=>o.role==="user"?{role:o.role,content:o.content}:o.role===t?{role:"assistant",content:o.content}:{role:"user",content:`***Agent '${o.role}' replied:***
${o.content}`})}getContributedEnhancers(){return b.getContributions(K).map(t=>({...t.enhancer,priority:t.priority??t.enhancer.priority}))}async build(e,t,o,s){s?.beforeSend&&await s.beforeSend(t,o);const n=this.sanitizeMessagesForAPI(t),r=this.rewriteChatHistoryForAgent(n,e.role);let i=e.tools;typeof i=="function"&&(i=await i());let a;if(i?.enabled)if(i.smartToolDetection){const g=t[t.length-1]?.content||"";await ye.needsTools(g)&&(a=this.toolRegistry.getAvailableTools(o,i.commandFilter))}else a=this.toolRegistry.getAvailableTools(o,i.commandFilter);const l=await this.getSysPrompt(e,o);r.unshift({role:"system",content:l});const d=r.length-1;return{messages:r,userPromptIndex:d,tools:a}}sanitizeMessageForAPI(e){const t={role:e.role,content:e.content};return"tool_call_id"in e&&e.tool_call_id&&(t.tool_call_id=e.tool_call_id),"tool_calls"in e&&e.tool_calls&&(t.tool_calls=e.tool_calls),t}sanitizeMessagesForAPI(e){return e.map(t=>this.sanitizeMessageForAPI(t))}}class we{constructor(){this.processors=[]}addProcessor(e){this.processors.push(e)}getSortedProcessors(){return[...this.processors].sort((e,t)=>(t.priority||0)-(e.priority||0))}async process(e,t,o){let s={...e};const n=[...t.messageProcessors||[],...this.processors].sort((i,a)=>(a.priority||0)-(i.priority||0));for(const i of n)s=await i.process(s,o);const r=s.actions?.some(i=>i.requiresAttention)||s.attentionRequests?.some(i=>i.requiresAction)||!1;return{...s,requiresAttention:r}}checkRequiresAttention(e){return e.actions?.some(t=>t.requiresAttention)||e.attentionRequests?.some(t=>t.requiresAction)||!1}}class Ae{constructor(){this.accumulatedToolCalls=new Map,this.toolCallIndexMap=new Map}processChunk(e){if(e.type==="token"&&e.toolCalls&&e.toolCalls.length>0)for(const t of e.toolCalls){const o=t._index,s=t.id;let n,r;if(o!==void 0&&this.toolCallIndexMap.has(o)?(r=this.toolCallIndexMap.get(o),n=this.accumulatedToolCalls.get(r)):s&&this.accumulatedToolCalls.has(s)?(r=s,n=this.accumulatedToolCalls.get(r)):(r=s||`call_${o!==void 0?o:Date.now()}_${Math.random()}`,n=void 0),n){const i=n.function.arguments||"",a=t.function.arguments||"",l=i+a;this.accumulatedToolCalls.set(r,{id:r,type:t.type||n.type,function:{name:t.function.name||n.function.name,arguments:l}}),o!==void 0&&!this.toolCallIndexMap.has(o)&&this.toolCallIndexMap.set(o,r)}else this.accumulatedToolCalls.set(r,{...t,id:r}),o!==void 0&&this.toolCallIndexMap.set(o,r)}}getFinalToolCalls(){return Array.from(this.accumulatedToolCalls.values()).filter(e=>e.function.name&&e.function.name.trim().length>0).map(e=>{let t=e.function.arguments||"";return(!t||t.trim()==="")&&(t="{}"),{...e,function:{...e.function,arguments:t}}})}reset(){this.accumulatedToolCalls.clear(),this.toolCallIndexMap.clear()}}class Y{sanitizeFunctionName(e){return e.replace(/[^a-zA-Z0-9_-]/g,"_").replace(/^[^a-zA-Z]/,"cmd_$&").replace(/_+/g,"_").replace(/^_|_$/g,"")}findCommand(e,t){const o=e.function.name,s=k.getCommand(o);if(s)return s;const n=k.listCommands();for(const[r,i]of Object.entries(n))if(this.sanitizeFunctionName(r)===o)return i;return null}parseArguments(e){if(!e||e.trim()===""||e==="{}")return{};try{const t=JSON.parse(e);return t&&typeof t=="object"?t:{}}catch(t){const o=t instanceof Error?t.message:String(t);return console.error(`[ToolExecutor] Failed to parse arguments: ${e} - ${o}`),{}}}sanitizeArguments(e,t){if(!t||!t.parameters||!e||typeof e!="object")return e||{};const o={};return t.parameters.forEach(s=>{const n=this.sanitizeFunctionName(s.name);n in e&&(o[s.name]=e[n])}),o}async executeToolCall(e,t){try{const o=this.findCommand(e,t),s=o?.id||e.function.name,n=e.function.arguments||"{}",r=this.parseArguments(n),i=this.sanitizeArguments(r,o),a=k.createExecutionContext(i),l={...t,...a,params:i};let d=await k.execute(s,l);const g={success:!0,message:`Command "${o?.name||s}" executed successfully`,command:s};if(i&&typeof i=="object"&&Object.keys(i).length>0&&(g.parameters=i),d){let y=d;if(y instanceof Promise&&(y=await y),g.result=y,o?.output&&o.output.length>0){const u=o.output.map(m=>`${m.name}: ${m.description||m.type||"value"}`).join(", ");g.output=u}}return{id:e.id,result:g}}catch(o){const s=o instanceof Error?o.message:String(o);let n=null;try{n=this.findCommand(e,t)}catch{n=null}const r=n?.name||e.function.name;let i=s;return s.includes("No handler found")||s.includes("No handlers registered")?i=`Command "${r}" cannot be executed. ${s}. This usually means the command is not available in the current context (e.g., a map editor may not be open or active).`:(s.includes("not available")||s.includes("GsMapEditor"))&&(i=`Command "${r}" cannot be executed: ${s}. Please ensure the required editor or component is open and active.`),{id:e.id,result:null,error:i}}}async executeToolCalls(e,t){const o=[];for(const s of e){const n=await this.executeToolCall(s,t);o.push(n)}return o}createToolCallAccumulator(){return new Ae}createToolCallSignature(e){const t=e.function.arguments||"{}";let o={};try{const n=JSON.parse(t);o=n&&typeof n=="object"?n:{}}catch{o={}}const s=o&&typeof o=="object"?Object.keys(o).sort().reduce((n,r)=>(n[r]=o[r],n),{}):{};return`${e.function.name}:${JSON.stringify(s)}`}}const Oe=Object.freeze(Object.defineProperty({__proto__:null,ToolExecutor:Y},Symbol.toStringTag,{value:"Module"}));class Te{async execute(e,t,o,s){const n=t.chatConfig;if(!n)throw new Error("Chat config is required");const r=e.map(async i=>{try{await s(i,t.chatContext.history,o.sharedState,n,t,o)}catch(a){const l=a instanceof Error?a:new Error(String(a));o.errors.set(i.role,l),t.onAgentError?.(i.role,l)}});await Promise.all(r)}}class ve{async execute(e,t,o,s){const n=t.chatConfig;if(!n)throw new Error("Chat config is required");let r=[...t.chatContext.history],i={...o.sharedState};for(const a of e)try{const l=this.createAgentContextWithPreviousAgents(i,t,o),d=await s(a,r,i,n,t,o);if(!d)break;const c=this.updateWorkflowState(d,r,i,l,o);r=c.currentMessages,i=c.accumulatedState}catch(l){const d=l instanceof Error?l:new Error(String(l));o.errors.set(a.role,d),t.onAgentError?.(a.role,d);break}}createAgentContextWithPreviousAgents(e,t,o){return{...e,...t.callContext.getProxy(),previousAgents:Array.from(o.messages.entries()).map(([s,n])=>({role:s,content:n.content}))}}updateWorkflowState(e,t,o,s,n){return t.push(e),o={...o,...s,message:e},n.sharedState=o,{currentMessages:t,accumulatedState:o}}}class ke{async execute(e,t,o,s){const n=t.chatConfig;if(!n)throw new Error("Chat config is required");let r=[...t.chatContext.history],i={...o.sharedState};for(const a of e)try{const l=this.createAgentContextWithPreviousAgents(i,t,o);if(a.canHandle&&!a.canHandle(l))continue;const d=await s(a,r,i,n,t,o);if(!d)break;const c=this.updateWorkflowState(d,r,i,l,o);r=c.currentMessages,i=c.accumulatedState}catch(l){const d=l instanceof Error?l:new Error(String(l));o.errors.set(a.role,d),t.onAgentError?.(a.role,d)}}createAgentContextWithPreviousAgents(e,t,o){return{...e,...t.callContext.getProxy(),previousAgents:Array.from(o.messages.entries()).map(([s,n])=>({role:s,content:n.content}))}}updateWorkflowState(e,t,o,s,n){return t.push(e),o={...o,...s,message:e},n.sharedState=o,{currentMessages:t,accumulatedState:o}}}class _e{constructor(){this.strategies=new Map([["parallel",new Te],["sequential",new ve],["conditional",new ke]])}registerStrategy(e,t){this.strategies.set(e,t)}async execute(e,t,o){const s=`workflow-${Date.now()}-${Math.random()}`,n=t.execution||"parallel",r=t.sharedState||{},i={messages:new Map,sharedState:{...r},errors:new Map};C(U,{workflowId:s,options:t});try{const a=this.strategies.get(n);if(!a)throw new Error(`Unknown workflow execution strategy: ${n}`);return await a.execute(e,t,i,o),C(W,{workflowId:s,results:i}),i}catch(a){const l=a instanceof Error?a:new Error(String(a));throw C(H,{workflowId:s,error:l}),l}}}const _=class _{static estimateTokens(e){if(!e||e.trim().length===0)return 0;const t=e.trim(),o=t.length,s=t.split(/\s+/).filter(r=>r.length>0).length,n=Math.ceil(o/this.AVERAGE_CHARS_PER_TOKEN+s*.3);return Math.max(1,n)}static estimateMessageTokens(e){let t=this.MESSAGE_OVERHEAD;if(e.content&&(t+=this.estimateTokens(e.content)),e.role&&(t+=this.estimateTokens(e.role)),e.tool_calls)for(const o of e.tool_calls)t+=this.estimateTokens(o.function.name||""),t+=this.estimateTokens(o.function.arguments||"{}"),t+=10;return e.tool_call_id&&(t+=this.estimateTokens(e.tool_call_id)),t}static estimatePromptTokens(e,t){let o=0;for(const s of e)o+=this.estimateMessageTokens(s);if(t&&t.length>0){for(const s of t)if(o+=this.TOOL_DEFINITION_OVERHEAD,o+=this.estimateTokens(s.function.name||""),o+=this.estimateTokens(s.function.description||""),s.function.parameters){const n=JSON.stringify(s.function.parameters);o+=this.estimateTokens(n)}}return o}static estimateCompletionTokens(e,t){let o=this.estimateTokens(e);if(t&&t.length>0)for(const s of t)o+=10,o+=this.estimateTokens(s.function?.name||""),o+=this.estimateTokens(s.function?.arguments||"{}");return o}};_.AVERAGE_CHARS_PER_TOKEN=4,_.TOOL_DEFINITION_OVERHEAD=50,_.MESSAGE_OVERHEAD=4;let E=_;const D="ai_token_usage";class Pe{constructor(){this.data=null,this.loadPromise=null}async loadData(){return this.data?this.data:this.loadPromise?this.loadPromise:(this.loadPromise=(async()=>{const e=await $.getObject(D);return e?this.data=e:(this.data={providers:{},total:{promptTokens:0,completionTokens:0,totalTokens:0,requestCount:0},lastUpdated:Date.now()},await this.saveData()),this.loadPromise=null,this.data})(),this.loadPromise)}async saveData(){this.data&&(this.data.lastUpdated=Date.now(),await $.persistObject(D,this.data))}async recordUsage(e,t){if(await this.loadData(),!this.data)return;this.data.providers[e]||(this.data.providers[e]={promptTokens:0,completionTokens:0,totalTokens:0,requestCount:0});const o=this.data.providers[e];o.promptTokens+=t.promptTokens,o.completionTokens+=t.completionTokens,o.totalTokens+=t.totalTokens,o.requestCount+=1,this.data.total.promptTokens+=t.promptTokens,this.data.total.completionTokens+=t.completionTokens,this.data.total.totalTokens+=t.totalTokens,this.data.total.requestCount+=1,await this.saveData()}async getProviderUsage(e){return await this.loadData(),this.data?.providers[e]||null}async getAllProviderUsage(){return await this.loadData(),this.data?.providers||{}}async getTotalUsage(){return await this.loadData(),this.data?.total||{promptTokens:0,completionTokens:0,totalTokens:0,requestCount:0}}async reset(){this.data={providers:{},total:{promptTokens:0,completionTokens:0,totalTokens:0,requestCount:0},lastUpdated:Date.now()},await this.saveData()}async resetProvider(e){if(await this.loadData(),!this.data)return;const t=this.data.providers[e];t&&(this.data.total.promptTokens-=t.promptTokens,this.data.total.completionTokens-=t.completionTokens,this.data.total.totalTokens-=t.totalTokens,this.data.total.requestCount-=t.requestCount,delete this.data.providers[e],await this.saveData())}}const xe=new Pe;class Ee{constructor(){this.activeRequests=new Map,this.providerFactory=new ge,this.agentRegistry=new me,this.promptBuilder=new Ce,this.messageProcessor=new we,this.toolExecutor=new Y,this.workflowEngine=new _e,this.toolRegistry=new Z,ne(se,()=>{this.aiConfig=void 0,this.configCheckPromise=void 0,this.checkAIConfig().then()}),this.checkAIConfig().then()}getAgentContributions(){return this.agentRegistry.getAgentContributions()}async getProviders(){return await this.checkAIConfig(),this.aiConfig?.providers||[]}async getDefaultProvider(){await this.checkAIConfig();const e=await this.getProviders();if(this.aiConfig?.defaultProvider){const t=e.find(o=>o.name===this.aiConfig?.defaultProvider);if(t)return t}return e[0]}async setDefaultProvider(e){return await this.checkAIConfig(),this.aiConfig&&(this.aiConfig.defaultProvider=e,await v.set(A,this.aiConfig)),this.getDefaultProvider()}createMessage(e){return{role:"user",content:e}}registerStreamingFetcher(e){this.providerFactory.registerProvider(e)}getContributedProviders(){return b.getContributions(G).map(t=>t.provider)}mergeProviders(e,t){const o=new Set(e.map(n=>n.name)),s=t.filter(n=>!o.has(n.name));return s.length>0?[...e,...s]:e}async createInitialConfig(){const e=this.getContributedProviders(),t={...J,providers:e};return await v.set(A,t),await v.get(A)}async updateConfigWithMissingProviders(e){const t=this.getContributedProviders(),o=this.mergeProviders(e.providers,t);if(o.length!==e.providers.length){const s={...e,providers:o};return await v.set(A,s),s}return e}async checkAIConfig(){if(!this.aiConfig)return this.configCheckPromise?this.configCheckPromise:(this.configCheckPromise=this.performConfigCheck(),this.configCheckPromise)}async performConfigCheck(){try{this.aiConfig=await v.get(A),this.aiConfig?this.aiConfig=await this.updateConfigWithMissingProviders(this.aiConfig):this.aiConfig=await this.createInitialConfig(),C(z,this.aiConfig)}finally{this.configCheckPromise=void 0}}createAgentContext(e,t,o={}){return{...e,...t.getProxy(),...o}}createFinalMessage(e,t){return{role:e.role,content:t.content,actions:t.actions,requiresAttention:t.requiresAttention,attentionRequests:t.attentionRequests,canContinue:t.canContinue}}async handleUserAttention(e,t,o,s){if(!t.requiresAttention||!o.userAttentionHandler)return!0;const n=[];if(t.attentionRequests&&n.push(...t.attentionRequests),t.actions)for(const a of t.actions)a.requiresAttention&&a.attentionRequest&&n.push(a.attentionRequest);if(n.length===0)return!0;if(s.pendingAttention||(s.pendingAttention=new Map),s.pendingAttention.set(e,n),o.onAttentionRequest)for(const a of n)o.onAttentionRequest(e,a);if(o.pauseOnAttention)return s.paused=!0,s.continuationToken=`${e}-${Date.now()}-${Math.random()}`,!1;const r=o.userAttentionHandler,i=this.createAgentContext(o.sharedState||{},o.callContext,{message:t});for(const a of n)if(r.onAttentionRequest){const l=await r.onAttentionRequest(a,i);if(a.requiresAction&&(l===!1||l===null))return!1;l&&typeof l=="string"&&(i[`attention_${a.type}_result`]=l)}else switch(a.type){case"confirmation":if(r.onConfirmation&&!await r.onConfirmation(a.message,i)&&a.requiresAction)return!1;break;case"input":if(r.onInput){const l=await r.onInput(a.message,void 0,i);if(!l&&a.requiresAction)return!1;l&&(i.attention_input_result=l)}break}return!0}async*streamCompletion(e){const t=`${Date.now()}-${Math.random()}`,o=new AbortController;this.activeRequests.set(t,o),e.signal&&e.signal.addEventListener("abort",()=>{o.abort()});const s=e.signal||o.signal;try{e.onStatus?.("starting"),C(N,{requestId:t,options:e});const n=e.chatConfig||await this.getDefaultProvider(),r=this.sanitizeMessagesForAPI(e.chatContext.history),i=this.providerFactory.getProvider(n),a=this.toolExecutor.createToolCallAccumulator();let l="",d={role:"assistant",content:""},c;for await(const u of i.stream({model:n.model,messages:r,chatConfig:n,tools:e.tools,signal:s})){if(u.type==="error"){e.onStatus?.("error"),C(x,{requestId:t,chunk:u}),yield u;break}if(u.type==="token")a.processChunk(u),(!u.toolCalls||u.toolCalls.length===0)&&(l+=u.content,d.content=l),u.message?.role&&(d.role=u.message.role),u.content&&e.onToken?.(u.content),e.onStatus?.("streaming"),e.onProgress?.({received:l.length}),C(F,{requestId:t,chunk:u}),yield u;else if(u.type==="done"){u.metadata?.usage&&(c=u.metadata.usage),e.onStatus?.("complete"),C(L,{requestId:t}),yield u;break}else yield u}const g=a.getFinalToolCalls(),y={role:d.role||"assistant",content:l||"",...g.length>0&&{toolCalls:g}};if(!c){const u=E.estimatePromptTokens(r,e.tools),m=E.estimateCompletionTokens(l,g);c={promptTokens:u,completionTokens:m,totalTokens:u+m,estimated:!0}}return xe.recordUsage(n.name,c).catch(u=>{re.error(`Failed to record token usage: ${u instanceof Error?u.message:String(u)}`)}),{message:y,tokenUsage:c}}catch(n){if(n instanceof Error&&n.name==="AbortError")throw e.onStatus?.("error"),C(x,{requestId:t,error:"Request cancelled"}),n;e.onStatus?.("error");const r=n instanceof Error?n.message:String(n);throw C(x,{requestId:t,error:r}),yield{type:"error",content:r,metadata:{error:n}},n}finally{this.activeRequests.delete(t)}}async handleStreamingPromptDirect(e){const t=this.streamCompletion(e);let o;for(;;){if(o=await t.next(),o.done)return o.value.message;const s=o.value;if(s.type==="error")throw new Error(s.content);if(s.type==="done"){const n=await t.next();if(n.done&&n.value)return n.value.message;if(!n.done)continue;throw new Error("Stream completed without return value")}}}sanitizeMessageForAPI(e){const t={role:e.role,content:e.content};return"tool_call_id"in e&&e.tool_call_id&&(t.tool_call_id=e.tool_call_id),"tool_calls"in e&&e.tool_calls&&(t.tool_calls=e.tool_calls),t}sanitizeMessagesForAPI(e){return e.map(t=>this.sanitizeMessageForAPI(t))}async handleStreamingPrompt(e){const t=e.callContext||ae.createChild({}),o=this.createAgentContext({},t,{userPrompt:e.chatContext.history[e.chatContext.history.length-1]?.content||""}),s=this.agentRegistry.getMatchingAgents(o),n=s.length>0?s.map(a=>a.role):["assistant"],r=await this.executeAgentWorkflow({chatContext:e.chatContext,chatConfig:e.chatConfig,callContext:t,execution:"parallel",stream:e.stream,signal:e.signal,onToken:(a,l)=>{e.onToken?.(l)},onStatus:(a,l)=>{e.onStatus?.(l)},roles:n}),i=Array.from(r.messages.values());return i.length===1?i[0]:i}async continueWorkflow(e,t,o){const s={sharedState:{...o.sharedState,...Object.fromEntries(t)}},n={...o,sharedState:s.sharedState,pauseOnAttention:!1};return this.executeAgentWorkflow(n)}cancelRequest(e){const t=this.activeRequests.get(e);return t?(t.abort(),this.activeRequests.delete(e),!0):!1}async executeAgentWorkflow(e){const t=this.createAgentContext(e.sharedState||{},e.callContext),o=this.agentRegistry.getMatchingAgents(t,e.roles);return this.workflowEngine.execute(o,e,async(s,n,r,i,a,l)=>this.executeAgent(s,n,r,i,a,l))}async executeAgent(e,t,o,s,n,r){n.onAgentStart?.(e.role);const i=this.createAgentContext(o,n.callContext,{userPrompt:t[t.length-1]?.content||""}),{messages:a,tools:l}=await this.promptBuilder.build(e,t,i,e.hooks),d=a.map(p=>{const T={role:p.role,content:p.content};return p.tool_call_id&&(T.tool_call_id=p.tool_call_id),p.tool_calls&&(T.tool_calls=p.tool_calls),T});let c=await this.handleStreamingPromptDirect({chatContext:{history:d},chatConfig:s,callContext:n.callContext,stream:n.stream??!0,signal:n.signal,tools:l}),g=0;const y=[...a];for(;c.toolCalls&&c.toolCalls.length>0;){if(g++,g>M){console.warn(`[AIService] Maximum tool call iterations (${M}) reached`);break}let p=[];if(n.requireToolApproval&&n.onToolApprovalRequest){const h=c.toolCalls.map(P=>{const ee=P.function.arguments||"{}";let S={};try{S=JSON.parse(ee)}catch{S={}}return`${P.function.name}(${Object.entries(S).map(([q,te])=>`${q}=${te}`).join(", ")})`}).join(", "),Q={toolCalls:c.toolCalls,message:`The AI wants to execute: ${h}`};await n.onToolApprovalRequest(e.role,Q)?p=await this.toolExecutor.executeToolCalls(c.toolCalls,i):p=c.toolCalls.map(P=>({id:P.id,result:{success:!1,message:"Tool execution cancelled by user",cancelled:!0}}))}else p=await this.toolExecutor.executeToolCalls(c.toolCalls,i);const T=p.map(h=>({role:"tool",content:h.error?JSON.stringify({error:h.error}):JSON.stringify(h.result),tool_call_id:h.id})),I={role:"assistant",content:c.content||""};c.toolCalls&&c.toolCalls.length>0&&(I.tool_calls=c.toolCalls.filter(h=>h.function.name&&h.function.name.trim().length>0).map(h=>({id:h.id,type:h.type,function:{name:h.function.name,arguments:h.function.arguments||"{}"}}))),y.push(I,...T);const X=y;c=await this.handleStreamingPromptDirect({chatContext:{history:X.map(h=>({role:h.role,content:h.content,...h.tool_call_id&&{tool_call_id:h.tool_call_id},...h.tool_calls&&{tool_calls:h.tool_calls}}))},chatConfig:s,callContext:n.callContext,stream:n.stream??!0,signal:n.signal,tools:l});const R=c.content&&c.content.trim().length>0,O=c.toolCalls&&c.toolCalls.length>0;if(R&&!O)break;if(R&&O){console.warn("[AIService] Model provided content but also called tools - treating as completion");break}}const u=await this.messageProcessor.process(c,e,this.createAgentContext(o,n.callContext,{message:c}));e.hooks?.afterReceive&&await e.hooks.afterReceive(u,this.createAgentContext(o,n.callContext));const m=this.createFinalMessage(e,u);return!await this.handleUserAttention(e.role,m,n,r)&&n.pauseOnAttention?null:(r.messages.set(e.role,m),n.onAgentComplete?.(e.role,m),m)}}const qe=new Ee;export{K as C,A as K,ge as P,z as T,qe as a,G as b,L as c,j as d,Re as e,Oe as f,xe as t};
