import{c as l}from"./main-CqI8UPkK.js";import{GitHubUrlParser as a}from"./github-url-parser-DrTlzD8v.js";const r=l("GitHubExtensionLoader"),f="https://esm.sh",u="https://api.github.com",c=class c{static toEsmShUrl(t,s){const n=t.ref||"main",o=s.startsWith("/")?s.substring(1):s;return`${f}/gh/${t.owner}/${t.repo}@${n}/${o}`}static async discoverEntryPoint(t){const s=t.ref||"main";if(t.path){const n=t.path.endsWith(".ts")||t.path.endsWith(".tsx"),o=this.toEsmShUrl(t,t.path);return{path:t.path,isTypeScript:n,cdnUrl:o}}try{const n=await this.fetchPackageJson(t);if(n?.main){const o=n.main,e=o.endsWith(".ts")||o.endsWith(".tsx"),i=this.toEsmShUrl(t,o);return r.debug(`Found entry point from package.json: ${o}`),{path:o,isTypeScript:e,cdnUrl:i}}}catch(n){r.debug(`Could not fetch package.json: ${n}`)}for(const n of this.ENTRY_POINTS)try{const o=this.toEsmShUrl(t,n);if((await fetch(o,{method:"HEAD"})).ok){const i=n.endsWith(".ts")||n.endsWith(".tsx");return r.debug(`Found entry point: ${n}`),{path:n,isTypeScript:i,cdnUrl:o}}}catch(o){r.debug(`Entry point ${n} not found: ${o}`)}throw new Error(`Could not discover entry point for ${t.owner}/${t.repo}@${s}. Tried: ${this.ENTRY_POINTS.join(", ")} and package.json main field.`)}static async fetchPackageJson(t){const s=t.ref||"main",n=`${u}/repos/${t.owner}/${t.repo}/contents/package.json?ref=${s}`;try{const o=await fetch(n,{headers:{Accept:"application/vnd.github.v3+json"}});if(!o.ok)return null;const e=await o.json();if(e.content&&e.encoding==="base64"){const i=atob(e.content);return JSON.parse(i)}return null}catch(o){return r.debug(`Failed to fetch package.json from GitHub API: ${o}`),null}}static async resolveExtensionUrl(t){const s=a.parse(t),n=await this.discoverEntryPoint(s);return r.info(`Resolved GitHub extension URL: ${t} -> ${n.cdnUrl}`),n.cdnUrl}static isGitHubUrl(t){return a.isValid(t)}};c.ENTRY_POINTS=["index.ts","index.tsx","extension.ts","extension.tsx","index.js","extension.js","main.js"];let h=c;export{h as GitHubExtensionLoader};
