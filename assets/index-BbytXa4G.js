import{aD as S,aE as _,aF as F,aG as g,aH as N,aI as K,aJ as L,aK as W,aL as Z,aM as H,aN as J,aO as h,aP as X,aQ as Y,aR as k,aS as ee,aT as te,aU as re,aV as ne,aW as se,aX as ae,aY as oe,aZ as ce,a_ as ue,a$ as ie,b0 as le,b1 as pe,b2 as $e,b3 as fe,b4 as de,b5 as be,b6 as he,b7 as ge,b8 as M,b9 as ye,ba as R,bb as q,bc as Oe,bd as j,be as me,bf as E,bg as _e,bh as je,bi as x,bj as T,bk as xe,bl as G,bm as P,c as Se,al as Ee}from"./rx-query-helper-BcrKuOYb.js";const we=(e,t,a)=>{const s=S(e,t,null,a);return _(s,a.useStrictMode)&&s.every(r=>_(r,a.useStrictMode))},Me=(e,t,a)=>{const s=F(t);if(s.length==0)return!1;if(s.length==1)return!S(e,s[0],null,a);throw"Expression $not takes exactly 1 argument"},qe=(e,t,a)=>{const s=S(e,t,null,a),r=a.useStrictMode;return _(s,r)&&s.some(c=>_(c,r))},De=Object.freeze(Object.defineProperty({__proto__:null,$and:we,$not:Me,$or:qe},Symbol.toStringTag,{value:"Module"})),Ae=(e,t,a)=>{const s=S(e,t,null,a);return s[0]>s[1]?1:s[0]<s[1]?-1:0},Re=g(N),Te=g(K),Ue=g(L),Pe=g(W),ze=g(Z),Ge=g(H),ve=Object.freeze(Object.defineProperty({__proto__:null,$cmp:Ae,$eq:Re,$gt:Te,$gte:Ue,$lt:Pe,$lte:ze,$ne:Ge},Symbol.toStringTag,{value:"Module"}));function Qe(e,t,a){return s=>S(s,t,null,a)}function Be(e,t,a){if(!a?.jsonSchemaValidator)throw new J("Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.");const s=a?.jsonSchemaValidator(t);return r=>s(r)}function Ie(e,t,a){h(a.scriptEnabled,"$where operator requires 'scriptEnabled' option to be true");const s=t;return h(X(s),"$where only accepts a Function object"),r=>_(s.call(r),a?.useStrictMode)}const D=e=>Y((t,a,s)=>{let r=0;if(a instanceof Array)for(const c of a)r=r|1<<c;else r=a;return e(t&r,r)}),Ve=D((e,t)=>e==0),Ce=D((e,t)=>e==t),Fe=D((e,t)=>e<t),Ne=D((e,t)=>e>0),Ke=Object.freeze(Object.defineProperty({__proto__:null,$all:k,$and:ee,$bitsAllClear:Ve,$bitsAllSet:Ce,$bitsAnyClear:Fe,$bitsAnySet:Ne,$elemMatch:te,$eq:re,$exists:ne,$expr:Qe,$gt:se,$gte:ae,$in:oe,$jsonSchema:Be,$lt:ce,$lte:ue,$mod:ie,$ne:le,$nin:pe,$nor:$e,$not:fe,$or:de,$regex:be,$size:he,$type:ge,$where:Ie},Symbol.toStringTag,{value:"Module"})),U=(e,t)=>{switch(e){case"deep":return me(t);case"copy":return Oe(t)?new Date(t):q(t)?[...t]:j(t)?{...t}:t;default:return t}},Le=/^[a-z]+[a-zA-Z0-9]*$/;function v(e){if(!e.includes(".$"))return[{parent:e,selector:e},[]];const t=e.indexOf(".$"),a=e.indexOf("]"),s=e.substring(0,t),r=e.substring(t+3,a);h(r===""||Le.test(r),"The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters.");const c=e.substring(a+2),[u,n]=c?v(c):[];return[{selector:e,parent:s,child:r||"$",next:u},[r,...n||[]].filter(Boolean)]}const $=(e,t,a,s,r)=>{const{parent:c,child:u,next:n}=t;if(!u){let l=!1;return ye(e,c,(p,d)=>l=!!s(p,d)||l,r),l}const o=R(e,c);return q(o)?o.map((l,i)=>a[u]&&!a[u].test({[u]:l})?!1:n?$(l,n,a,s,r):s(o,i)).some(Boolean):!1};function f(e,t,a,s){const r=[];for(const[c,u]of Object.entries(e)){const[n,o]=v(c);if(!o.length)s(u,n,{})&&r.push(n.parent);else{const l={};t.forEach(p=>{Object.keys(p).forEach(d=>{o.forEach(b=>{(d===b||d.startsWith(b+"."))&&(l[b]=l[b]||{},Object.assign(l[b],{[d]:p[d]}))})})});const i={};for(const[p,d]of Object.entries(l))i[p]=new M(d,a.queryOptions);s(u,n,i)&&r.push(n.parent)}}return r}const We=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>{const n={$each:[r]};return j(r)&&E(r,"$each")&&Object.assign(n,r),$(e,c,u,(o,l)=>{const i=o[l]||=[];return _e([i,n.$each]).length===n.$each.length?!1:(o[l]=U(s.cloneMode,je(i.concat(n.$each))),!0)},{buildGraph:!0})}),Ze=new Set(["and","or","xor"]),He=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>{const n=Object.keys(r);return h(n.length===1&&Ze.has(n[0]),`Invalid bit operator '${n[0]}'. Must be one of 'and', 'or', or 'xor'.`),$(e,c,u,(o,l)=>{let i=o[l];const p=r[n[0]];if(i!==void 0&&!(x(i)&&x(p)))return!1;switch(i=i||0,n[0]){case"and":o[l]=i&p;break;case"or":o[l]=i|p;break;case"xor":o[l]=i^p;break}return o[l]!==i},{buildGraph:!0})}),Je=(e,t,a=[],s={})=>{const r=Date.now();return f(t,a,s,(c,u,n)=>$(e,u,n,(o,l)=>(o[l]=r,!0),{buildGraph:!0}))},Xe=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>{if(!c.child){const n=R(e,c.parent);h(n===void 0||x(n),"cannot apply $inc to a value of non-numeric type")}return $(e,c,u,(n,o)=>(n[o]=(n[o]||=0)+r,!0),{buildGraph:!0})}),Ye=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>n[o]!==void 0&&T(n[o],r)>-1?!1:(n[o]=r,!0),{buildGraph:!0})),ke=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>n[o]!==void 0&&T(n[o],r)<1?!1:(n[o]=r,!0),{buildGraph:!0})),et=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>{const l=n[o];return n[o]=n[o]===void 0?0:n[o]*r,n[o]!==l},{buildGraph:!0})),tt=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>{const l=n[o];return h(q(l),`path '${c.selector}' contains an element of non-array type.`),l.length?(r===-1?l.splice(0,1):l.pop(),!0):!1})),Q=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>{const n=!j(r)||Object.keys(r).some(xe),o=new M(n?{k:r}:r,s.queryOptions),l=n?i=>o.test({k:i}):i=>o.test(i);return $(e,c,u,(i,p)=>{const d=i[p],b=new Array;return d.map(w=>{const O=l(w);return O||b.push(w),O}).some(Boolean)?(i[p]=b,!0):!1})}),rt=(e,t,a=[],s={})=>{const r={};return Object.entries(t).forEach(([c,u])=>{r[c]={$in:u}}),Q(e,r,a,s)},nt=Object.freeze(["$each","$slice","$sort","$position"]),st=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>{const n={$each:[r]};return j(r)&&nt.some(o=>E(r,o))&&Object.assign(n,r),$(e,c,u,(o,l)=>{const i=o[l]||=[],p=i.slice(0,n.$slice||i.length),d=i.length,b=x(n.$position)?n.$position:i.length;if(i.splice(b,0,...U(s.cloneMode,n.$each)),n.$sort){const y=j(n.$sort)?Object.keys(n.$sort||{}).pop():"",w=y?n.$sort[y]:n.$sort,O=y?m=>R(m,y):m=>m;i.sort((m,C)=>w*T(O(m),O(C)))}return x(n.$slice)&&(n.$slice<0?i.splice(0,i.length+n.$slice):i.splice(n.$slice)),d!=i.length||!G(p,i)},{descendArray:!0,buildGraph:!0})}),B=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>G(n[o],r)?!1:(n[o]=U(s.cloneMode,r),!0),{buildGraph:!0})),at=(e,t,a=[],s={})=>{const r=[],c=f(t,a,s,(u,n,o)=>$(e,n,o,(l,i)=>E(l,i)?(r.push(...B(e,{[u]:l[i]},a,s)),delete l[i],!0):!1));return Array.from(new Set(c.concat(r)))},ot=(e,t,a=[],s={})=>f(t,a,s,(r,c,u)=>$(e,c,u,(n,o)=>E(n,o)?(q(n)?n[o]=null:delete n[o],!0):!1)),z=Object.freeze(Object.defineProperty({__proto__:null,$addToSet:We,$bit:He,$currentDate:Je,$inc:Xe,$max:Ye,$min:ke,$mul:et,$pop:tt,$pull:Q,$pullAll:rt,$push:st,$rename:at,$set:B,$unset:ot},Symbol.toStringTag,{value:"Module"}));function I(e){return e={...e,queryOptions:P(e.queryOptions)},e.queryOptions.context.addQueryOps(Ke).addExpressionOps(De).addExpressionOps(ve),(t,a,s=[],r={},c={})=>{const u=Object.assign({cloneMode:"copy"},e,c);Object.assign(u,{queryOptions:P(Object.assign({useStrictMode:!1},u?.queryOptions))}),s=s||[],r=r||{};const n=Object.entries(a);h(n.length===1,"Update expression must contain only one operator.");const[o,l]=n[0];h(E(z,o),`Update operator '${o}' is not supported.`);const i=z[o];return Object.keys(r).length&&!(r instanceof M?r:new M(r,u.queryOptions)).test(t)?[]:i(t,l,s,u)}}I({});var A;function V(e,t){if(!A){var a=I({cloneMode:"none"});A=(s,r)=>{var c=Se(s);return a(c,r),c}}return A(e,t)}function ct(e){return this.incrementalModify(t=>{var a=V(t,e);return a})}function ut(e){var t=this._data,a=V(t,e);return this._saveData(a,t)}async function it(e){return Ee(this.asRxQuery,t=>t.update(e))}var pt={name:"update",rxdb:!0,prototypes:{RxDocument:e=>{e.update=ut,e.incrementalUpdate=ct},RxQuery:e=>{e.update=it}}};export{pt as RxDBUpdatePlugin,it as RxQueryUpdate,ct as incrementalUpdate,ut as update};
