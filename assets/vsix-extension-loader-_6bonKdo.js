import{o as C,c as I,p as R,w as S,F,a as P,b as y,C as L}from"./main-CqI8UPkK.js";import{J as T}from"./jszip.min-DvwSm7v9.js";const c=I("VSIXLoader"),V="vsix_extensions/";class O{constructor(){this.loadedExtensions=new Map}async loadFromOpenVSX(n){const e=C.getExtensionId(n),t=this.loadedExtensions.get(e);if(t&&t.version===n.version)return c.debug(`Using cached VSIX for ${e}`),t;const o=C.getDownloadUrl(n);if(!o)throw new Error(`No download URL available for extension ${e}`);return c.info(`Loading VSIX from Open VSX: ${e} v${n.version}`),await this.loadFromUrl(o,n)}async loadFromUrl(n,e){try{c.debug(`Downloading VSIX from: ${n}`);const t=await fetch(n);if(!t.ok)throw new Error(`HTTP ${t.status}: ${t.statusText}`);const o=await t.blob();return await this.extractVSIX(o,e)}catch(t){throw c.error(`Failed to load VSIX from URL ${n}: ${t}`),t}}async extractVSIX(n,e){try{c.debug("Extracting VSIX file...");const t=await T.loadAsync(n),o=t.file("extension/package.json")||t.file("package.json");if(!o)throw new Error("VSIX file does not contain package.json");const a=await o.async("string"),r=JSON.parse(a),i=e?C.getExtensionId(e):`${r.publisher||"unknown"}.${r.name}`,l=e?.namespace||r.publisher||"unknown",g=e?.name||r.name,h=e?.version||r.version,d=new Map;if(!r.browser)throw new Error(`Extension ${i} does not have a browser entry point. Only web extensions are supported.`);let p=r.browser;c.debug(`Using browser entry point (web extension): ${p}`),p=p.replace(/^\.\//,""),c.debug(`Processing VSIX files for ${i}, entry point: ${p}`);for(const[x,$]of Object.entries(t.files))if(!$.dir)try{const k=await $.async("string");d.set(x,k)}catch{try{const M=await(await $.async("blob")).text();d.set(x,M)}catch(j){c.warn(`Failed to extract file ${x}: ${j}`)}}c.info(`Extracted ${d.size} files from VSIX`);const f=Array.from(d.keys()).filter(x=>x.endsWith(".js")&&!x.includes("node_modules"));c.info(`JavaScript files in VSIX (${f.length}): ${f.slice(0,20).join(", ")}${f.length>20?"...":""}`);const w=f.filter(x=>{const $=d.get(x);return $&&$.length>1e3});c.info(`Large JavaScript files (>1KB, ${w.length}): ${w.join(", ")}`);const m=Array.from(d.keys()).filter(x=>x.includes(p)||x.endsWith(p)||x.endsWith("/"+p));if(m.length>0)c.debug(`Found potential entry point files: ${m.join(", ")}`);else{const x=Array.from(d.keys()).filter($=>$.endsWith(".js")).slice(0,10);c.debug(`Available JS files (first 10): ${x.join(", ")}`)}const A=this.isWebExtension(r);A||c.warn(`Extension ${i} is not a web extension. Only web extensions (with browser entry point) are supported.`);const v={manifest:r,extensionId:i,namespace:l,name:g,version:h,files:d,entryPoint:p,isWebExtension:A};return await this.cacheVSIX(v),this.loadedExtensions.set(i,v),c.info(`Successfully extracted VSIX: ${i} v${h}`),v}catch(t){throw c.error(`Failed to extract VSIX: ${t}`),t}}async cacheVSIX(n){try{const e=`${V}${n.extensionId}/${n.version}`;await R.persistObject(e,{manifest:n.manifest,extensionId:n.extensionId,namespace:n.namespace,name:n.name,version:n.version,files:Object.fromEntries(n.files),entryPoint:n.entryPoint,isWebExtension:n.isWebExtension})}catch(e){c.warn(`Failed to cache VSIX: ${e}`)}}async getCachedVSIX(n,e){try{const t=`${V}${n}/${e}`,o=await R.getObject(t);if(o){const a={manifest:o.manifest,extensionId:o.extensionId,namespace:o.namespace,name:o.name,version:o.version,files:new Map(Object.entries(o.files||{})),entryPoint:o.entryPoint};return this.loadedExtensions.set(n,a),a}}catch{c.debug(`No cached VSIX found for ${n} v${e}`)}return null}getLoadedVSIX(n){return this.loadedExtensions.get(n)}getEntryPointCode(n){let e=n.entryPoint||"extension.js";e=e.replace(/^\.\//,""),c.info(`Looking for entry point: ${e} for extension ${n.extensionId}`);const t=[`extension/${e}`,e,`extension/out/${e}`,`out/${e}`,`extension/extension/${e}`,`extension/browser/${e}`,`browser/${e}`];for(const r of t){const i=n.files.get(r);if(i)return c.info(`Found entry point at: ${r} (${i.length} chars)`),c.info(`Entry point content: ${i.substring(0,200)}${i.length>200?"...":""}`),i}const o=Array.from(n.files.keys());c.info(`Entry point not found in standard paths. Available files (${o.length} total):`),c.info(`First 50 files: ${o.slice(0,50).join(", ")}`);const a=o.filter(r=>r.endsWith(e)||r.endsWith("/"+e)||r.includes("/"+e)||r===e);if(a.length>0){c.info(`Found matching file: ${a[0]}`);const r=n.files.get(a[0]);if(r)return c.info(`Loaded entry point from: ${a[0]} (${r.length} chars)`),r}return c.error(`Entry point not found for ${n.extensionId}: ${e}`),c.error(`Searched paths: ${t.join(", ")}`),c.error(`Files containing '${e}': ${a.join(", ")||"none"}`),null}getFile(n,e){return n.files.get(e)||null}isWebExtension(n){return!!(n.browser||n.extensionKind&&(n.extensionKind.includes("web")||n.extensionKind.includes("ui"))||!n.main&&!n.browser)}}const E=new O,u=I("VSCodeAPIAdapter");class q{constructor(n){this.commandHandlers=new Map,this.loadedVSIX=n,this.extensionContext=this.createExtensionContext()}createExtensionContext(){return{extensionPath:`vsix:${this.loadedVSIX.extensionId}`,subscriptions:[],workspaceState:{},globalState:{},extensionUri:null,extension:{id:this.loadedVSIX.extensionId,extensionPath:`vsix:${this.loadedVSIX.extensionId}`}}}getContext(){return this.extensionContext}createVSCodeAPI(){const n=this;return{commands:{registerCommand:(e,t,o)=>{if(u.info(`[VS Code API] registerCommand called: ${e}`),u.debug(`[VS Code API] Callback type: ${typeof t}, thisArg: ${o?"provided":"none"}`),u.debug(`[VS Code API] Callback: ${t.toString().substring(0,200)}...`),typeof t!="function")throw u.error(`[VS Code API] registerCommand called with non-function callback for ${e}`),new Error("registerCommand callback must be a function");const a={canExecute:()=>!0,execute:async i=>{try{u.debug(`[VS Code API] Executing command handler: ${e}`);const l=i.params?Object.values(i.params):[],g=await t.apply(o,l);return u.debug(`[VS Code API] Command ${e} executed successfully`),g}catch(l){throw u.error(`Error executing VS Code command ${e}: ${l}`),l}}};if(!y.hasCommand(e)){const i=new L(e,e,`VS Code command: ${e}`);y.registerCommand(i)}y.registerHandler(e,a),n.commandHandlers.set(e,t);const r={dispose:()=>{u.debug(`Disposing VS Code command: ${e}`),n.commandHandlers.delete(e)}};return n.extensionContext.subscriptions.push(r),r},executeCommand:async(e,...t)=>(u.debug(`Executing VS Code command: ${e}`),await y.execute(e,{params:t})),getCommands:async()=>Array.from(n.commandHandlers.keys())},workspace:{workspaceFolders:[],getConfiguration:e=>({get:(t,o)=>(u.debug(`Getting config: ${e}.${t}`),o),update:async(t,o)=>{u.debug(`Updating config: ${e}.${t}`)},has:t=>!1,inspect:t=>{}}),onDidChangeConfiguration:e=>{const t={dispose:()=>{}};return n.extensionContext.subscriptions.push(t),t},openTextDocument:async e=>{u.debug(`Opening text document: ${e}`);const t=typeof e=="string"?e:e.fsPath||e.path,o=await S.getWorkspace();if(!o)throw new Error("No workspace available");const a=await o.getResource(t);if(!a||!(a instanceof F))throw new Error(`File not found: ${t}`);return{uri:{fsPath:t,path:t},fileName:t,getText:async()=>await a.getContents({contentType:P.TEXT})}},fs:{readFile:async e=>{const t=e.fsPath||e.path||e,o=await S.getWorkspace();if(!o)throw new Error("No workspace available");const a=await o.getResource(t);if(a&&a instanceof F){const r=await a.getContents({contentType:P.TEXT});return typeof r=="string"?new TextEncoder().encode(r):r}throw new Error(`File not found: ${t}`)},writeFile:async(e,t)=>{const o=e.fsPath||e.path||e,a=await S.getWorkspace();if(!a)throw new Error("No workspace available");const r=await a.getResource(o,{create:!0});r&&r instanceof F&&await r.saveContents(t,{contentType:P.BINARY})}}},window:{showInformationMessage:(e,...t)=>(u.info(`[VS Code Extension] ${e}`),Promise.resolve(void 0)),showWarningMessage:(e,...t)=>(u.warn(`[VS Code Extension] ${e}`),Promise.resolve(void 0)),showErrorMessage:(e,...t)=>(u.error(`[VS Code Extension] ${e}`),Promise.resolve(void 0)),createOutputChannel:e=>({append:t=>u.debug(`[${e}] ${t}`),appendLine:t=>u.debug(`[${e}] ${t}`),show:()=>{},hide:()=>{},dispose:()=>{}}),activeTextEditor:void 0,onDidChangeActiveTextEditor:e=>{const t={dispose:()=>{}};return n.extensionContext.subscriptions.push(t),t}},extensions:{getExtension:e=>{if(e===n.loadedVSIX.extensionId)return{id:n.loadedVSIX.extensionId,extensionPath:n.extensionContext.extensionPath,packageJSON:n.loadedVSIX.manifest}}},ExtensionContext:class{constructor(e){this.extensionPath=e}}}}dispose(){for(const n of this.extensionContext.subscriptions)try{n.dispose()}catch(e){u.warn(`Error disposing subscription: ${e}`)}this.extensionContext.subscriptions=[]}}function W(b){const n=new q(b);return{vscode:n.createVSCodeAPI(),context:n.getContext()}}const s=I("VSIXExtensionLoader");class U{async loadFromOpenVSX(n){try{s.info(`Loading VSIX extension from Open VSX: ${n.namespace}.${n.name}`);const e=await E.loadFromOpenVSX(n);await this.activateExtension(e)}catch(e){throw s.error(`Failed to load VSIX extension: ${e}`),e}}async loadFromUrl(n,e){try{s.info(`Loading VSIX extension from URL: ${n}`);const t=await E.loadFromUrl(n,e);await this.activateExtension(t)}catch(t){throw s.error(`Failed to load VSIX extension from URL: ${t}`),t}}async activateExtension(n){try{if(s.debug(`Activating VSIX extension: ${n.extensionId}`),!n.isWebExtension){const r=`Extension ${n.extensionId} is not a web extension. Only web extensions (with browser entry point) are supported.`;throw s.error(r),new Error(r)}s.info(`Loading web extension ${n.extensionId}`);const e=E.getEntryPointCode(n);if(!e)throw new Error(`Entry point not found for extension ${n.extensionId}`);const{vscode:t,context:o}=W(n);this.registerCommandsFromManifest(n,t);const a=this.createActivateFunction(e,t,o,n);if(a&&typeof a=="function")try{s.info(`Calling activate function for ${n.extensionId}...`);const r=console.log,i=console.error,l=[];console.log=(...g)=>{l.push(`[EXT LOG] ${g.map(h=>String(h)).join(" ")}`),r.apply(console,g)},console.error=(...g)=>{l.push(`[EXT ERROR] ${g.map(h=>String(h)).join(" ")}`),i.apply(console,g)};try{const g=await a(o);s.info(`Activate function completed for ${n.extensionId}, result: ${g}`),l.length>0&&s.debug(`Extension console output (${l.length} lines): ${l.slice(0,10).join("; ")}${l.length>10?"...":""}`);const d=y.getHandler("quarto.newDocument")?.length||0;s.info(`Handlers for quarto.newDocument after activation: ${d} (expected: 2 - manifest + extension)`),d===1&&s.warn("Extension did not register handlers via vscode.commands.registerCommand() - commands may not work")}finally{console.log=r,console.error=i}s.info(`Successfully activated VSIX extension: ${n.extensionId}`)}catch(r){s.error(`Extension ${n.extensionId} activation function threw an error: ${r}`),s.error(`Activation error stack: ${r instanceof Error?r.stack:String(r)}`),s.debug("This may be expected if the extension uses a different activation pattern")}else s.info(`Extension ${n.extensionId} loaded (no activate function, may use declarative contributions only)`)}catch(e){throw s.error(`Failed to activate VSIX extension: ${e}`),e}}registerCommandsFromManifest(n,e){const t=n.manifest.contributes;if(!t||!t.commands){s.debug(`No commands found in manifest for ${n.extensionId}`);return}s.info(`Registering ${t.commands.length} command metadata from manifest for ${n.extensionId}`),s.info("Extension will register actual handlers via vscode.commands.registerCommand()");for(const o of t.commands)if(typeof o=="object"&&o.command&&o.title){const a=o.command,r=new L(a,o.title,o.category||o.title);y.registerCommand(r),s.debug(`Registered command metadata from manifest: ${a} - ${o.title}`)}else s.warn(`Invalid command definition in manifest: ${JSON.stringify(o)}`);s.info(`Successfully registered ${t.commands.length} command metadata entries from manifest`),s.info("Note: Commands will only appear in palette after extension registers handlers via vscode.commands.registerCommand()")}createActivateFunction(n,e,t,o){const a={},r=i=>{if(s.info(`[Module Require] Requesting module: ${i}`),i==="vscode")return s.info("[Module Require] Returning vscode API"),e;if(i==="Buffer"||i==="buffer")return s.warn("[Module Require] Buffer requested - web extensions should use Uint8Array instead"),globalThis.Buffer||null;const l=this.resolveModulePath(o,i);return l?(s.info(`[Module Require] Found file for module: ${i} -> ${l.path} (${l.content.length} chars)`),this.evaluateModule(l.content,e,t,o)):(s.warn(`[Module Require] Module not found: ${i}`),{})};try{s.info(`Creating activate function for ${o.extensionId}, code length: ${n.length} chars`),s.info(`First 500 chars of extension code: ${n.substring(0,500)}${n.length>500?"...":""}`);const i=new Function("exports","require","module","__filename","__dirname","vscode","context",n);s.info(`Executing extension code for ${o.extensionId}...`);const l=console.error,g=console.log,h=[],d=[];console.error=(...f)=>{h.push(f),l.apply(console,f)},console.log=(...f)=>{d.push(f),g.apply(console,f)};try{i(a,r,{exports:a},"","",e,t),s.info("Extension code executed successfully"),h.length>0&&(s.warn(`Extension code had ${h.length} console.error calls during execution`),h.slice(0,5).forEach((f,w)=>{s.warn(`Extension error ${w+1}: ${f.map(m=>String(m)).join(" ")}`)})),d.length>0&&(s.info(`Extension code had ${d.length} console.log calls during execution`),d.slice(0,5).forEach((f,w)=>{s.info(`Extension log ${w+1}: ${f.map(m=>String(m)).join(" ")}`)}))}catch(f){throw s.error(`Error executing extension code: ${f}`),s.error(`Stack: ${f instanceof Error?f.stack:String(f)}`),f}finally{console.error=l,console.log=g}const p=Object.keys(a);return s.info(`Extension ${o.extensionId} exports: ${p.join(", ")||"none"}`),typeof a.activate=="function"?(s.info(`Found activate function for ${o.extensionId}`),a.activate):typeof a.default=="function"?(s.debug(`Found default export function, using as activate for ${o.extensionId}`),a.default):(p.length>0?s.debug(`Extension ${o.extensionId} exports: ${p.join(", ")} (no activate function, may be declarative only)`):s.debug(`Extension ${o.extensionId} has no exports (may be declarative only - contributions registered from manifest)`),()=>{})}catch(i){throw s.error(`Failed to create activate function: ${i}`),s.error(`Error details: ${i instanceof Error?i.stack:String(i)}`),i instanceof Error&&i.message.includes("not a constructor")&&(s.error("This error typically indicates the extension requires Node.js APIs that are not available in the browser."),s.error(`Extension ${o.extensionId} may not be a web extension.`)),i}}resolveModulePath(n,e){const t=[e,`extension/${e}`,`extension/out/${e}`,`extension/out/browser/${e}`,`out/${e}`,`out/browser/${e}`,`browser/${e}`,e.replace(/^\.\//,""),`extension/${e.replace(/^\.\//,"")}`];for(const r of t){const i=n.files.get(r);if(i)return{path:r,content:i}}const a=Array.from(n.files.keys()).filter(r=>r.endsWith(e)||r.endsWith("/"+e)||r.includes("/"+e.replace(/^\.\//,"")));if(a.length>0){const r=n.files.get(a[0]);if(r)return{path:a[0],content:r}}return null}evaluateModule(n,e,t,o){const a={},r=i=>{if(i==="vscode")return e;if(i==="Buffer"||i==="buffer")return s.warn("[Module Require] Buffer requested in web extension - using global Buffer if available"),globalThis.Buffer||null;const l=E.getFile(o,i);return l?this.evaluateModule(l,e,t,o):(s.warn(`[Module Require] Module not found: ${i} (web extensions should not require Node.js modules)`),{})};try{return new Function("exports","require","module","__filename","__dirname","vscode","context",n)(a,r,{exports:a},"","",e,t),a}catch(i){return s.warn(`Failed to evaluate module: ${i}`),{}}}}const J=new U;export{U as VSIXExtensionLoader,J as vsixExtensionLoader};
