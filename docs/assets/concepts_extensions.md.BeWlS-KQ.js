import{_ as t,o as n,c as o,ae as d}from"./chunks/framework.CXxCM6l_.js";const x=JSON.parse('{"title":"Extensions","description":"","frontmatter":{},"headers":[],"relativePath":"concepts/extensions.md","filePath":"concepts/extensions.md"}'),a={name:"concepts/extensions.md"};function i(r,e,s,c,l,h){return n(),o("div",null,[...e[0]||(e[0]=[d('<h1 id="extensions" tabindex="-1">Extensions <a class="header-anchor" href="#extensions" aria-label="Permalink to &quot;Extensions&quot;">​</a></h1><p><strong>Extensions</strong> are feature units that register with the framework and can provide commands, UI contributions, and editors.</p><h2 id="extension-interface" tabindex="-1">Extension interface <a class="header-anchor" href="#extension-interface" aria-label="Permalink to &quot;Extension interface&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Field</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td><code>id</code></td><td>Yes</td><td>Unique id (e.g. <code>@kispace-io/extension-command-palette</code>, typically the package name).</td></tr><tr><td><code>name</code></td><td>Yes</td><td>Human-readable name (can be an i18n label).</td></tr><tr><td><code>description</code></td><td>No</td><td>Short description.</td></tr><tr><td><code>loader</code></td><td>No</td><td>Function that dynamically imports the extension module. Runs when the extension is enabled.</td></tr><tr><td><code>url</code></td><td>No</td><td>URL to load the extension from (alternative to loader).</td></tr><tr><td><code>icon</code></td><td>No</td><td>Icon identifier (e.g. FontAwesome name).</td></tr><tr><td><code>version</code></td><td>No</td><td>Extension version.</td></tr><tr><td><code>author</code></td><td>No</td><td>Author name.</td></tr><tr><td><code>experimental</code></td><td>No</td><td>Mark as experimental.</td></tr><tr><td><code>external</code></td><td>No</td><td>Set when the extension comes from the marketplace.</td></tr><tr><td><code>dependencies</code></td><td>No</td><td>List of extension ids that must load before this one.</td></tr></tbody></table><h2 id="lifecycle" tabindex="-1">Lifecycle <a class="header-anchor" href="#lifecycle" aria-label="Permalink to &quot;Lifecycle&quot;">​</a></h2><ol><li>The app lists extension ids in <code>AppDefinition.extensions</code>.</li><li>The app loader enables those extensions (and their dependencies).</li><li>For each extension, the <strong>loader</strong> is run (or the module at <strong>url</strong> is loaded).</li><li>The loader module registers commands, contributions, and editors with the framework.</li><li>When the app is unloaded, extensions are disabled.</li></ol><h2 id="one-package-per-extension" tabindex="-1">One package per extension <a class="header-anchor" href="#one-package-per-extension" aria-label="Permalink to &quot;One package per extension&quot;">​</a></h2><p>Each extension typically lives in its own package under <code>packages/extension-*</code>, depends on <code>@kispace-io/core</code>, and has an entry file that registers the extension and a loader that imports the module that does the real registration.</p><h2 id="dependencies" tabindex="-1">Dependencies <a class="header-anchor" href="#dependencies" aria-label="Permalink to &quot;Dependencies&quot;">​</a></h2><p>Use <code>dependencies</code> so that another extension is loaded first (e.g. Python runtime before the notebook). The system resolves order and detects circular dependencies.</p><p>See <a href="/docs/guide/create-an-extension.html">Create an extension</a>.</p>',11)])])}const m=t(a,[["render",i]]);export{x as __pageData,m as default};
